# Шпаргалка по JavaScript #
 
  <details><summary><b>Замыкания</b></summary><p>
    
  * v1 - Функция, содержащая в себе ссылки на переменные из внешней области видимости..
  * v2 - Функция вместе со всеми внешними переменными, которые ей доступны.
  * v3 - Функция, получающая переменные из родительской области видимости.
  * v4 - Способность функции запоминать контекст(т.е. LexicalEnvironment), в которой она была создана.
    
  У каждой функции есть область видимости. С внутренней функции мы можем доставать переменные с внешней функции. И еще менять.<br> 
  Это называют "брать из замыкания".<br>
  Вроде бы, в функциональном программировании такой подход не приветствуется. Но знатьу и уметь надо, а в JS - обязательно.
   
  Например, функция запоминила значение "a" из области своего создания. Её вызывают уже вне этой области, а она возвращает это "а.<br> 
  Т.е. она "замыкает" внешние переменные в себе.
  
  Вот ты вызвал функцию, в ней создаются переменные локальной области видимости, т.е. доступные только самой функции.<br>
  Под эти переменные движок JavaScript выделяет память.
  
  Когда обычная функция завершает свое выполнение - она освобождает память, которую выделял раньше, если на переменные не осталось ссылок.
  
  В случае с замыканием, ты возвращаешь функцию обратно, т.е. ссылки остаются, поэтому движок не может освободить память, и переменные остаются доступными функции, и более никому. Поэтому эта штука и называется замыкание, т.к. переменные замкнуты на саму функцию.
  
  Другими словами, чтобы создать замыкание, ты должен вложить функцию в функцию, обратиться из вложенной функции к переменным оборачивающей, и вложенную функцию вернуть наружу. До тех пор, пока возвращенная функция остается в доступе, замыкание существует.
  
  Один из основных паттернов, для которых применяются замыкания - ограничение доступа к данным, их изоляция (ограничение их области видимости).
  
  В то же время замыкание выступает в роли автономного атомарного хранилища данных, и, по идее, должно обеспечивать доступ к этим данным, тем или иным способом.
      
  <b>«Понимать замыкания»</b> в JavaScript означает понимать следующие вещи:
  * Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
  * При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
  * При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».
  
  ```
    function sayHi(name) {
      var phrase = "Привет, " + name;
      alert( phrase );
    }
    
    sayHi('Вася');
  ```    
  
  **Ссылки:**
  * [learn.javascript.ru](https://learn.javascript.ru/closures)
  * [habr - Замыкания в JavaScript](https://habr.com/ru/post/38642/)
  * [htmlacademy - Замыкания в JavaScript](https://htmlacademy.ru/blog/useful/javascript/lets-learn-javascript-closures)
  * [MDN - Замыкания](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)
  * [Wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
        
  <br></p></details>
  

  <details><summary><b>Стрелочные функции</b></summary><p>
    
  Не имеют своего this. Внутри стрелочных функций тот же this, что и снаружи. Удобно в обработчиках событий и коллбэках.<br>
  Не имеют своего arguments. Используются аргументы внешней «обычной» функции.<br>
  Появились в ES6.
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/es-function)
        
  <br></p></details>
         
         
  <a name="js_callback"></a>
  <details><summary><b>Callback</b></summary><p>
    
  Функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback – функция обратного вызова).
   
  Сами не вызываем функцию. Отдаём её как аругмент в другую функции, и та вызывает, когда сочтёт нужным.
   
  Чуть сложнее: В JavaScript функции – это объекты. Поэтому функции могут принимать другие функции в качестве аргументов, а также функции могут возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего порядка. А любая функция, которая передается как аргумент, называется callback-функцией.
    
  Пример: 
    ``<button onClik={function}>txt</button>``<br> 
  Когда произойдёт событие onClick, кнопка вызовет эту функцию.
  Нет скобок после function - мы не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо. От своего имени
  
  Неправильно: 
    ``<button onClik={function()}>txt</button>``<br> 
  Здесь функция не передаётся, а сразу вызывается.
      
  <b>Зачем?</b>
  JS - событийно-ориентированный язык. Если функция не отвечает немедленно (например выполянет AJAX-запрос или Timeout) - JS не будет останавливать работу, ожидая ответа. Он продолжит выполнение других функций, одновременно ожидая ответа от нашей функции. Вывод: нельзя просто вызывать функции в нужном порядке и надеяться, что они в обязательно выполнятся в том же порядке.<br>
  
  Пример: 
  ```
    function first(){
      // Как будто бы запрос к API
      setTimeout( function(){
        console.log(1);
      }, 500 );
    }
    function second(){
      console.log(2);
    }
    first();
    second();
    
    //Выдаст ответ:
    // 2
    // 1
  ```
  Коллбэки позволяют нам быть уверенными в том, что определенный код не начнет исполнение до того момента, пока другой код не завершит исполнение.     
      
  При вызове callback может нарушиться контекст вызова this. Т.е. отвалиться привязка this к родительскому объекту.
  ```
  <App
      addQuote={store.addQuote}
    />
  ```
  
  В таком случае, при создании callback надо сделать привязку контекста - bind
  ```
    <App
      addQuote={store.addQuote.bind(store)} 
    />
  ```
  
  Функции call() и apply() - ещё один способ вызова callback-функции. Здесь мы сами устанавливаем контекст, в котором выполняется функция. Это означает, что когда мы используем ключевое слово this внутри нашей callback-функции, оно ссылается на то, что мы передаём первым аргументом в call()/apply. (см. ниже)
  
  Пример:
  ```
  function showFullName() {alert(что-нибудь)}
  
  var user = {что-то}
  
  function_name.call(user); // вызываем колбек и в качестве контекста this передаём ему user

  ```
  
  Ссылки:
  * [habr - Понимание callback-функций (колбеков)](https://habr.com/ru/post/151716/)
  * [hexlet](https://ru.hexlet.io/blog/posts/javascript-what-the-heck-is-a-callback)
  
  <br></p></details>


  <a name="js_cal-aply"></a>
  <details><summary><b>"Call" & "apply"</b> //ToDo - доработать</summary><p>
  
  Явное указание this
  
  Мы сами устанавливаем контекст, в котором выполняется функция. Это означает, что когда мы используем ключевое слово this внутри нашей callback-функции, оно ссылается на то, что мы передаём первым аргументом в call()/apply
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/call-apply)
  * [habr](https://habr.com/ru/post/199456/) 
  
  <br></p></details>   


  <a name="js_bind"></a>
  <details><summary><b>Bind</b></summary><p> 
    
  Метод. Позволяет привязать контекст к функции. Важно при callback
  
  Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
    
  При вызове callback может нарушиться контекст вызова this. Т.е. отвалиться привязка this  к родительскому объекту.
  ```
      <App
        addQuote={store.addQuote} //нет скобок после addQuote
      />
  ```
  Не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо, от своего имени.
  
  В таком случае, при создании callback надо сделать привязку контекста - bind
  ```    
      <App
        addQuote={store.addQuote.bind(store)} 
      />
  ```
  
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/bind)
  * [code.mu](http://code.mu/javascript/context/bind.html) 
  * [habr](https://habr.com/ru/post/199456/) 
  * [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
  <br></p></details>
    
  <a name="js_events-handlers"></a>
  <details><summary><b>Обработчики событий</b> (events handlers)</summary><p>
    
  Блоки кода (обычно функции), которые позволяют обрабатывать события (щелчок мыши...) и реагировать на них.
  
  Когда такой блок кода определяют для запуска в ответ на некое событие, говорят "мы регистрируем обработчик событий". 
  Иногда обработчики называют прослушивателями событий (event listeners). Термины часто взаимозаменяемы, но вообще: _прослушиватель_ слушает событие, а _обработчик_ — это код, который запускается в ответ на событие.
  
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/introduction-browser-events)
  * [MDN](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F)
  * [professorweb.ru](https://professorweb.ru/my/javascript/js_theory/level2/2_5.php)
      
  <br></p></details>
        
   
  <a name="js_objects-arrays"></a>
  <details><summary><b>Объекты {} и массивы []</b></summary><p>
                                                  
  - ``{ width: 300,  height: 200, }`` - объект. Структура для хранения данных в формате ключ-значение.
  - ``[ 300, 200, ]``                 - массив. Для хранения пронумерованных значений. Особый тип объектов. 
        
 Объект - ассоциативный массив: структура, пригодная для хранения любых данных. В других языках программирования такую структуру данных также называют «словарь» и «хэш». В JS объекты также используются как элементы ООП, это немного отдельно. 
  
 Массивы обычно используются для хранения _упорядоченных_ коллекций данных, например – списка товаров на странице, студентов в группе и т.п. Предлагает дополнительные методы для удобного манипулирования такой коллекцией. Элементы в массиве должны идти подряд, иначе теряется большая часть преимуществ этой структуры.
    
  Ссылки:
  * [learn.javascript.ru - Массивы](https://learn.javascript.ru/array)
  * [learn.javascript.ru - Объекты](https://learn.javascript.ru/object)
      
  <br></p></details>
  
  <details><summary><b>var = х</b></summary><p>
  
  Способ объявления переменной. Используем в обычных случаях
  
  Область видимости переменной var – функция.
  
  var существуют и до объявления. Они равны undefined.
  
  При использовании в цикле у нас будет одна var на все итерации цикла. Не создаётся заново в каждой итерации.
  
  Не надо объявлять переменные без указания директивы (например var или let). 
  ```
  //Т.е. так писать не стоит
  a = 1
  
  //Надо так
  var a = 1
  
  //Или так
  let a = 1
  
  //Или так
  const a = 1
  ```
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/variables)
  * [learn.javascript.ru](https://learn.javascript.ru/let-const)
       
  <br><p></details>
  

  <details><summary><b>let = х</b></summary><p>
    
  Способ объявления переменной. Используем если будем переопределять значение переменной. Видна в блоке
  
  Область видимости переменной let – блок {...}, в котором объявлена.<br>
  Это, в частности, влияет на объявления внутри if, while или for.
  
  let видна только после объявления. До тех пор их просто нет.
  
  При использовании в цикле, для каждой итерации создаётся своя переменная.
  
  Введена в язык в ES6 (ES-2015)
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/variables)
  * [learn.javascript.ru](https://learn.javascript.ru/let-const)
       
  <br><p></details>

  <details><summary><b>const = х</b></summary><p>

  Способ объявления переменной. Используем для констант 

  Объявление const задаёт константу, то есть переменную, которую нельзя менять. При попытке изменения выдаст ошибку.
  
  Eсли в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё.
  
  В остальном - аналогичная let.
  
  Функции обычно лучше создавать через const.
  
  Вообще хороший вариант объявления чего-то, что мы не собираемся менять.
  
  Константы, которые жёстко заданы всегда, во время всей программы, обычно пишутся в верхнем регистре. Например: const ORANGE = "#ffa500".
  
  Большинство переменных – константы в другом смысле: они не меняются после присвоения. Но при разных запусках функции это значение может быть разным. Для таких переменных можно использовать const и обычные строчные буквы в имени.
  
  Использование const вместо var или let не говорит от том, что значение является константой или что оно иммутабельно (неизменяемо). Ключевое слово const просто указывает компилятору следить за тем, что переменной больше не будет присвоено никаких других значений.
  
  В случае использования const современные JavaScript-движки могут выполнить ряд дополнительных оптимизаций.
  
  Введена в язык в ES6 (ES-2015)
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/variables)
  * [learn.javascript.ru](https://learn.javascript.ru/let-const)
       
  <br><p></details>
  
  <details><summary><b>Promises</b></summary><p>
    
  Cпособ организации асинхронного кода. Объект, который содержит своё состояние
  
  Способ использования:
    
   1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
   1. Внешний код, получив promise, навешивает на него обработчики.
   1. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
       
  Состояния promises:
  - вначале pending («ожидание»), 
  - затем либо fulfilled («выполнено успешно») 
  - либо rejected («выполнено с ошибкой»).
 
  На promise можно навешивать коллбэки двух типов:
  - onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
  - onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
  
  Обработчики назначаются вызовом `then/catch`
  - .then = универсальный метод для навешивания обработчиков:
      - promise.then(onFulfilled, onRejected) //(удачно, неудачно)
  - .catch = чтобы поставить обработчик только на ошибку
      - вместо .then(null, onRejected) 
      - можно  .catch(onRejected) – это то же самое.
      
  Синхронный throw – то же самое, что reject<br>
  Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:
    ```      
      let prom = new Promise((resolve, reject) => {
        throw new Error("o_O");  // то же что reject(new Error("o_O"))
      })
      pprom.catch(alert); // Error: o_O
    ```
    
  <b>Сhaining (чейнинг)</b>- возможность строить асинхронные цепочки из промисов<br>
  Основная причина, из-за которой существуют и активно используются промисы.
  
  Например, мы хотим по очереди:
  * Загрузить данные посетителя с сервера (асинхронно).
  * Затем отправить запрос о нём на github (асинхронно).
  * Когда это будет готово, вывести его github-аватар на экран (асинхронно).
  * …И сделать код расширяемым, чтобы цепочку можно было легко продолжить.
  ```
    httpGet('/article/promise/user.json') //делаем запрос
    .then(...)
    .then(...)
    .then(...)
  ```
  При чейнинге .then…then…then, в каждый следующий then переходит результат от предыдущего.<br> 
  Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
  
  Ссылки:
  - [learn.javascript.ru](https://learn.javascript.ru/promise)
  - [habr - У нас проблемы с промисами](https://habr.com/ru/company/mailru/blog/269465/)
  - [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  - [habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
  
  <br></p></details>
  
    
  <details><summary><b>Async/Await</b></summary><p>
  
  Асинхронные функции на основе promises
  
  Асинхронные функции позволяют избавиться от так называемого «ада коллбэков» и улучшить внешний вид и читаемость кода.
  
  Работают поверх Promises
  
  Ключевое слово async сообщает JavaScript-интерпретатору о том, что функцию, объявленную с этим ключевым словом, нужно воспринимать по-особому. Систем приостанавливается, достигая ключевого слова await в этой функции. Она считает, что выражение после await возвращает промис и ожидает разрешения или отклонения этого промиса перед продолжением.
  
  В следующем примере функция getAmount() вызывает две асинхронные функции — getUser() и getBankBalance().<br>
  Сделать это можно и в промисе, но использование конструкции async/await позволяет решить эту задачу проще и элегантнее.
  
  Ссылки:
  * [habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
  * [habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
  * [learn.javascript.ru (en)](https://javascript.info/async-await)
  * [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  * [habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
  
  <br></p></details>
  
  
  <details><summary><b>Асинхронность в JS. Event loop</b> //ToDo - доработать</summary><p>
  
   Ну, это про то как устроена работа с асинхронными событиями в JS и браузере. И как они взаимодействуют.<br>
   Стэк вызова, очередь, event loop, web workers... Вот это вот всё...<br>
   Сюда же - микро-задачи и макро-задачи
   
   Почему promise отработают раньше timeout и т.д.<br>
     
  Ссылки:
  * [habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
  * [habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
  * [habr - Знай свой инструмент: Event Loop](https://habr.com/ru/post/336498/)
  * [learnjavascript - Управление памятью в JavaScript](https://learn.javascript.ru/memory-management)
  * [learn.javascript.ru (en)](https://javascript.info/async-await)
  * [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
  * [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
  * [Как управлять event loop в JavaScript. Часть 1](https://skillbox.ru/media/code/event_loop_chast_1/)
  * [Как управлять event loop в JavaScript. Часть 2](https://skillbox.ru/media/code/event_loop_chast_2/)
  * [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  * [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
  * [Hexlet](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/event-loop/theory_unit)
  * [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  * [habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
  * [pythontutor - как работает JS код](http://pythontutor.com/javascript.html#mode=display)
  * [learnjavascript - Про события и ассинхронность](https://learn.javascript.ru/events-and-timing-depth)
  
  <br></p></details>   
  
  <details><summary><b>Как работают современные движки JavaScript?</b> //ToDo - доработать</summary><p>
  
  Прежде всего, исходный код (текст на JS) проходит через парсер, в результате возникает внутреннее представление кода — абстрактное синтаксическое дерево. 
  
  Дальше работает интерпретатор. Отдельные функции при исполнении преобразуются в байт-код — по сути, последовательность вызовов внутренних функций интерпретатора. При этом накапливается статистика использования JS-функций. Если для какой-то отдельной функции преоделён порог вызовов, то принимается решение о том, что её нужно оптимизировать и она передаётся компилятору. Компилятор генерирует машинный код, который сильно завязан на типы входных значений.
  
  ![](https://hsto.org/r/w1560/webt/g-/tv/yx/g-tvyxlxy0e3kc0c_quq_r0d9uo.png)
  
  Допустим, у нас есть функция с двумя аргументами: foo(a, b), и мы вызываем её много раз с числовыми значениями параметров. В некоторый момент функция будет передана компилятору и станет выполняться быстрее. Допустим, мы вызовем её со строковым аргументом. В результате, движок выполнит «деоптимизацию»: передаст функцию от компилятора обратно интерпретатору, а готовый машинный код будет выброшен.
  
  **Ссылки**
  - [habr - Как работает JS (19 статей)](https://habr.com/ru/company/ruvds/blog/337042/)
  - [habr - Знакомство с WebAssembly](https://m.habr.com/ru/post/342180/)
  
  <br></p></details>   
  
  <details><summary><b>Proxy-объекты</b></summary><p>
    
  Особые объекты, позволяют перехватывать и изменять действия, выполняемые над другими объектами.

  В частности, речь идёт о вызове функций, об операциях присваивания, о работе со свойствами, о создании новых объектов, и так далее.<br>
  Эту технологию используют для блокирования прямого доступа к целевому объекту или целевой функции и организации взаимодействия с объектом или функцией через прокси-объект.
  
  Так выглядит объявление простого прокси-объекта, которому передаётся целевой объект и обработчик:<br>
  `let proxy = new Proxy(target, handler);`
  
  **Стандартное поведение объектов**<br>
  Объявим объект, а затем попробуем обратиться к несуществующему свойству этого объекта.
  ```
    let obj = {
      c: "car",
      b: "bike"
    };

    document.write(obj.b, ""); //Результат -> "bike"
    document.write(obj.c, ""); //Результат -> "car"
    document.write(obj.l); 	   //Результат -> "undefined"
  ```
  
  **Использование прокси для объекта**<br>
  Используем обработчик с перехватчиком get. Обработчик передаст целевой объект и запрошенный ключ перехватчику.
  ```
    let handler = {
        get: function(target, name) {
        return name in target ? target[name] : "Key does not exist";
      }
    }

    let obj = {
      c: "car",
      b: "bike"
    };

    let proxyObj = new Proxy(obj, handler);

    document.write(proxyObj.b, ""); //Результат -> "bike"
    document.write(proxyObj.c, ""); //Результат -> "car"
    document.write(proxyObj.l);     //Результат -> "Key does not exist"
  ```
  
  Ссылки:
  * [habr](https://habr.com/ru/company/ruvds/blog/359060/)
  
  <br></p></details>
  
  <details><summary><b>Функции-генераторы</b> - function* ()</summary><p>
    
  Могут приостанавливать своё выполнение, возвращать промежуточный результат и возобновляться позже.<br>
  Код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют «генератором»
  
  Генератор связан с итераторами. В частности, он является итерируемым объектом.
  
  Один генератор может включать в себя другие. Это называется композицией.
  
  **Плоский асинхронный код**
  
  Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
  
  Общий принцип такой:
  - Генератор yield'ит не просто значения, а промисы.
  - Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами next получает из него промисы – один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим next.
  - Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат – например, возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.

  Появились в ES6.
      
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/generator)
  
  <br></p></details>
  
  
  <details><summary><b>Итераторы</b></summary><p>
  
  Тип объектов, содержимое которых можно перебрать в цикле
    
  По сути - объект, предназначенный для перебора другого объекта.<br>
  Например массив, функция-генератор, список DOM-узлов, строка..
  
  Для перебора таких объектов добавлен новый синтаксис цикла: for..of.
  
  Итераторы дают возможность сделать «перебираемыми» любые объекты.
  
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/iterator)
    
  <br></p></details>
  
   
  <details><summary><b>function()()</b></summary><p>
    
  Зачем при вызове функции ставят две двойные скобки?
    
  Функция getFunc() возвращает другую функцию (та что в переменной func).<br> 
  Вторые скобки нужны чтобы вызвать функцию, которую вернула getFunc().<br>
  Если скобки опустить, то return внешней функции вернет Вам не результат а саму функцию. 
  
  Пример:
  ```
        var a = 1;
        function getFunc() {
          var a = 2;
          var func = function() { alert(a); };
          return func;
        }
        getFunc()(); // 2, из LexicalEnvironment функции getFunc
  ```

  <br></p></details>
  

  <details><summary><b>WebAssembly</b></summary><p>
  
  WebAssembly (WASM) — бинарный формат, позволяющий запускать код в браузере
  
  Точнее: бинарный формат инструкций для стековой виртуальной машины. WebAssembly спроектирован как портативная цель компиляции для высокоуровневых языков, таких как C/C++/Rust, которую можно развертывать в web для клиентских и серверных приложений.
  
  Представляет собой переносимое абстрактное синтаксическое дерево, обеспечивающее как более быстрый анализ, так и более быстрое выполнение кода, чем JavaScript.
  
  Это эффективный низкоуровневый байт-код для веб-приложений. Wasm даёт возможность разработки функционала веб-страниц на языках, отличных от JavaScript (например, это C, C++, Rust и другие). Код на этих языках компилируется (статически) в WebAssembly. В результате получается веб-приложение, которое быстро загружается и отличается очень высокой производительностью.
  
  **Зачем?**
  - быстро исполнять код в браузере. Быстрее чем JavaScript — в идеале, со скоростью света родного кода нашего процессора.
  - Zero configuration — решение «из коробки», без установки, нужен только браузер.
  - Безопасно — новая технология не должна создавать новых угроз.
  - Кросс-платформенно — у нас есть несколько платформ, включая мобильные, несколько операционных систем.
  - Удобно для разработчиков — нужны удобные средства разработки и отладки.
  
  В принципе,эту задачу решает JS. Что плохо: нужен плагин и/или runtime ⇒ нет zero configuration. У JS есть внутренние ограничения, которые уже не позволят сделать его радикально быстрее. 
  
  Потенциальные альтернативы (не прижились): 
  - NaCl (Native Client) - Google
  - PNaCl (Portable Native Client) - LLVM IR subset.
  - asm.js - Mozilla
  
  **Преимущества WebAssembly**
  - Скорость — почти как родной код.
  - Эффективность — бинарный формат, быстрый парсинг и компиляция.
  - Портируемость — все браузеры и операционные системы.
  - Безопасность — запуск в sandbox.
  - Удобство отладки — поддержка отладки в браузерах, отладчик есть уже сейчас.
  - Открытый стандарт — то есть это уже не инициатива отдельной компании, пытающейся «перетянуть одеяло на себя». Стандарт уже принят, в 2017 году.

  **Так что же такое WebAssembly?**
  - Бинарный формат
  - НЕ язык программирования, а байт-код. Мы же не называем Java-байткод языком программирования.
  - Загружается в браузер и исполняется в браузере. Формально, WebAssembly исполняется JavaScript-движком, а не самим браузером, поэтому есть и другие варианты исполнения, например, под NodeJS.
  - Исполняется виртуальной машиной. Это простая стековая машина с памятью, простота позволяет легко реализовать её для любого современного процессора.
  - НЕ имеет ничего общего с Web, кроме того что общается с внешним миром через JavaScript. Действительно, WebAssembly это просто виртуальная машина, имеющая память и исполняющая инструкции.
  
  **Unsorted**
  WebAssembly - это просто куски кода внутри js-программы которые работают максимально быстро. 
  Также и WebCL(использование параллельных вычеслений на видеокарте)
  
  Просто js работает в 2-5 раз медленнее чем аналогичная программа на Си (производительность отжирает интерпретатор). 
  Для преодоления этой проблемы в js внедряют WebAssembly и WebCL чтобы добиться максимально возможной производительности
  
  Улучшение JavaScript: Реализуйте все критичные вещи на wasm и импортируйте его как стандартный JavaScript модуль.
  
  WebAssembly определяет абстрактное синтаксическое дерево (как и JavaScript) в бинарном формате. Вы можете писать код и чистить его от ошибок в текстовом формате. WebAssembly легко читаем.
  
  Улучшение для браузеров: Браузеры будут понимать бинарный формат, а это значит, что разработчики смогут компилировать бинарники, которые можно сжать гораздо больше, чем используемые сегодня текстовые файлы с JavaScript. Чем меньше файл, тем быстрее загрузка. В зависимости от возможностей оптимизации времени компиляции, код на WebAssembly может передаваться и запускаться быстрее, чем на JavaScript!
  
  Цель для компиляции: Возможность другим языкам, получить первоклассную двоичную поддержку через весь стек веб-платформы.
  
  WebAssembly может увеличить скорость JavaScript в разы!
  
  WebAssembly позволяет использовать больше языков в веб-разработке
  
  WebAssembly добавляет вещи, которые большинство JS разработчиков не хотят видеть в JavaScript. Сама функциональность нужна, но вот в JavaScript ей места точно нет. Тем более, что мы можем получить все эти функции с помощью компиляции с других языков программирования.
  
  Фактически, WebAssembly предоставляет нам альтернативный компилятор — созданный специально для этих целей.
  
  Теперь, нам будет гораздо легче портировать код, который сильно зависит от, например, совместно используемых цепочек памяти. Я уверен, что написать компилятор для WebAssembly будет легче, чем написать компилятор для JavaScript, а все потому, что первый гарантирует лучший перенос функций языка в заданное абстрактное синтаксическое дерево.
  
  То, что все старые языки программирования теперь без проблем могут быть использованы в Сети — это хорошо, однако главное не в этом. 
  
  WebAssembly является отличным основанием для разработчиков начать работу над новыми языками программирования.
  
  <br>
  
  WebAssembly или wasm – это низкоуровневый формат байт-кода для клиентских скриптов на стороне браузера. 
  
  При компиляции в WebAssembly вы делаете свою программу доступной для всех платформ, на которых поддерживается wasm, другими словами, для всех браузеров (и не только)
  
  На практике WebAssembly реализуется разработчиками браузеров на основе существующего JavaScript-движка. По сути, он предназначен для замены JavaScript как целевого языка. Например, вместо компиляции TypeScript в JavaScript его разработчики теперь могут компилировать свой код в WebAssembly. Иными словами, это не новая виртуальная машина, это новый формат для той же самой виртуальной машины JavaScript, которая включена в каждый браузер. Это позволит использовать существующую инфраструктуру JavaScript без использования самого JavaScript.
  
  Во-первых, новый формат WebAssembly обещает значительное увеличение производительности парсинга - тип бинарного формата, используемый в WebAssembly, может быть декодирован гораздо быстрее, чем JavaScript может быть пропарсен (эксперименты показывают более чем 20-кратную разницу). Это позволит использовать в вебе ПО, которое раньше было бы нецелесообразно разрабатывать, например: виртуальные машины, виртуальную реальность, распознавание изображений и многое другое.
  
  Больше не придётся использовать JavaScript для веба, только потому что это единственное, что выполняется в браузере. JavaScript имеет плохую репутацию, хотя на самом деле это хороший язык в том, для чего он предназначен: позволяет быстро писать небольшие скрипты. Однако в настоящее время вы вынуждены использовать его для всего, что запускается в вебе, и это проблема для многих крупных проектов.
  
  WebAssembly можно будет переносить на другие платформы. Это означает, что, если вы пишете программное обеспечение на языке, который компилируется в WebAssembly, вы сможете запустить его на .NET. 
  
  <br>
  
  В отличие от других подходов для достижения нативного опыта, WebAssembly не требует встроенных плагинов, а запускается внутри веб-платформы. Это значит, что разработчики могут интегрировать библиотеки WebAssembly для сложных вычислительных процессов (сжатие данных, распознавание лиц) в существующие JavaScript-приложения для снижения нагрузки.
  
  WebAssembly – это инициатива, направленная на создание безопасного, переносимого и быстрого для загрузки и исполнения формата кода, подходящего для Web. WebAssembly – это не язык программирования. Это – цель компиляции, у которой имеются спецификации текстового и бинарного форматов. Это означает, что другие низкоуровневые языки, такие, как C/C++, Rust, Swift, и так далее, можно скомпилировать в WebAssembly. WebAssembly даёт доступ к тем же API, что и браузерный JavaScript, органично встраивается в существующий стек технологий. Для компиляции кода в формат WebAssembly используется Emscripten.
  
  Emscripten – это компилятор из байт-кода LLVM в JavaScript. То есть, с его помощью можно скомпилировать в JavaScript программы, написанные на C/C++ или на любых других языках, код на которых можно преобразовать в формат LLVM.
  
  Веб-приложения, написанные на WebAssembly, могут запускаться на скорости, близкой к нативной, потому что весь код анализируется и компилируется преждевременно. Браузер сразу видит инструкции на машинном языке, которые он может сразу проверить, оптимизировать и запустить.
  
  В каком-то смысле WebAssembly меняет работу веб-разработчика и фундаментальные свойства веба. С помощью WebAssembly и сопутствующего набора инструментов программы, написанные на C и C++, могут быть перемещены в веб для запуска с близкой к нативным приложениям производительностью. Мы ожидаем, что, с развитием WebAssembly, вы сможете поступать так же с языками создания мобильных приложений – то есть, Java, Swift и C#.
  
  <br>
  
  Время загрузки
  
  Для того, чтобы запустить JavaScript-программу, браузеру сначала нужно загрузить все .js-файлы, которые хранятся и передаются по сети в виде обычного текста.
  
  Wasm — это низкоуровневый язык, похожий на ассемблер. WebAssembly-программы загружаются браузером быстрее, так как через интернет нужно передать уже скомпилированные файлы в весьма компактном бинарном формате.
  
  
  Выполнение
  
  Сегодня wasm-программы выполняются лишь на 20% медленнее чем машинный код. Это, без сомнения, достойный результат. Ведь речь идёт о формате, который компилируется в особом окружении и запускается с применением множества ограничений, которые обеспечивают высокий уровень безопасности. Подобное замедление в сравнении с машинным кодом в этом свете выглядит не таким уж и большим. Кроме того, в будущем ожидается повышение производительности wasm-кода. 
  
  Ещё интереснее то, что wasm платформенно-независим. Его поддержка имеется во всех ведущих браузерных движках, которые демонстрируют примерно одинаковую производительность при выполнении wasm-кода. 
  
  
  Оптимизация кода
  
  Если рассматривать wasm в конвейере JS-движка, то окажется, что wasm-код не нуждается в анализе и в нескольких проходах компиляции. Он уже оптимизирован и готов к использованию. Т.е. мы проскакиваем несколько трудозатратных стадий.
    
  Wasm-код оптимизируется в ходе статической компиляции. При работе с ним не нужно разбирать текстовые файлы. Благодаря wasm в нашем распоряжении оказываются бинарные файлы, которые достаточно лишь преобразовать в машинный код. Все улучшения в этот код были внесены при компиляции, которая производится до того, как он попадает в браузер.
  Всё это делает выполнение wasm гораздо более эффективным, так как немало шагов по превращению текста программы в оптимизированный машинный код можно пропустить.

  **Ссылки:**
  - [habr - Знакомство с WebAssembly](https://m.habr.com/ru/post/342180/)
  - [habr - Как работает JS: особенности и сфера применения WebAssembly](https://habr.com/ru/company/ruvds/blog/343568/)
  - [habr - WebAssembly: начало новой эры](https://m.habr.com/ru/post/261205/)
  - [Почему WebAssembly значительно изменит веб](https://apptractor.ru/info/articles/pochemu-webassembly-znachitelno-izmenyaet-veb.html)
  - [Введение в WebAssembly: как устроена технология и почему она важна](https://tproger.ru/translations/introduction-to-webassembly/)
  - [Википедия - WebAssembly](https://ru.wikipedia.org/wiki/WebAssembly)
  
  <br></p></details>
  
  <details><summary><b>Деструктуризация массивов</b></summary><p>

  const [fruit, setFruit] = useState('банан');

  Такой синтаксис в JS называется «деструктуризацией массивов (array destructuring)». 
  Он означает, что мы создаём две новые переменные, fruit и setFruit. 
  Во fruit будет записано первое значение, вернувшееся из useState, а в setFruit — второе. 

  Это равносильно такому коду:
  ```
    var fruitStateVariable = useState('банан'); // Возвращает пару значений
    var fruit = fruitStateVariable[0]; // Извлекаем первое значение
    var setFruit = fruitStateVariable[1]; // Извлекаем второе значение
  ```
  
  Когда мы объявляем переменную состояния с помощью функции useState, мы получаем от неё пару, то есть массив из двух элементов. Первый элемент обозначает текущее значение, а второй является функцией, позволяющей менять это значение.
  
  <br></p></details>
  
  <details><summary><b>Утечки памяти в JS</b></summary><p>
    
  1. Глобальные переменные - неявное объявление<br>
    Пример:
    ```  
      function foo(arg) {
        bar = "скрытая глобальная переменная"; // это то же: window.bar = "явно объявленная глобальная переменная";
      }
    ```    
    Решение: добавляйте 'use strict'; в начало JavaScript-файлов
        
  2. Глобальные переменные - явно объявленные, не вычищенные (кэши и т.д.)<br>
  Это касается глобальных переменных, использующихся для временного хранения и обработки больших блоков данных. Если вам нужна глобальная переменная, чтобы записать в неё большое количество информации, убедитесь, что в конце работы с данными её значение будет установлено в null или переопределено. <br>
  Примером увеличенного расхода памяти, связанным с глобальными переменными, являются кэши — объекты, которые сохраняют повторно используемые данные. Для эффективной работы их следует ограничивать по размеру. Если кэш увеличивается без ограничений, он может привести к высокому расходу памяти, поскольку его содержимое не может быть очищено сборщиком мусора.
  
  3. Забытые таймеры и коллбэки<br> 
    Пример:
    ``` 
      var someResource = getData();
      setInterval(function() {
          var node = document.getElementById('Node');
          if(node) {
              // Сделаем что-нибудь с node и someResource.
              node.innerHTML = JSON.stringify(someResource));
          }
      }, 1000);
    ```
  
  4. Забытые обработчики событий<br>
    Обработчики следует удалять, когда они становятся не нужны, или ассоциированные с ними объекты становятся недоступны.<br> 
    В прошлом это было критично, так как некоторые браузеры (Internet Explorer 6) не умели грамотно обрабатывать циклические ссылки.<br> 
    Большинство современных браузеров удаляет обработчики событий, как только объекты становятся недостижимы. <br>
    Однако по-прежнему правилом хорошего тона остаётся явное удаление обработчиков событий перед удалением самого объекта.<br>
    Рекомендуется явно удалять обработчики событий (removeEventListener) до удаления DOM-узлов или обнулять ссылки внутри обработчиков.<br>
  
  5. Ссылки на удалённые из DOM элементы
  
  6. Замыкания - при опр. условиях
  
  Ссылки:
  *[habr](https://habr.com/ru/post/309318/)
  
  <br></p></details>
  
  <details><summary><b>Debounce</b></summary><p>
    
  "Декоратор" который возвращает обертку. Она откладывает вызов исходной функции на определенное время.
  
  Декораторы (микропаттерны оптимизации) функций позволяют добавить дополнительное поведение функции, не изменяя ее. 
    
  Превращает несколько вызовов функции в течение определенного времени в один вызов.<br> 
  Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова. 
  
  Возможны два варианта:
  - Реальный вызов происходит только в случае, если с момента последней попытки прошло время, большее или равное задержке.
  - Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не пройдет время, большее или равное задержке, отсчитанной от времени последней попытки.
  
  **Зачем?**<br>
  Обычно debounce используют, если исходная функция вызывается чаще, чем это требуется.<br>
  Например, DOM-события mousemove, resize, scroll генерируют очень частые вызовы обработчиков, поэтому в ряде случаев было бы полезно обернуть такие обработчики в debounce.<br>
  Другое применение – контроль пользовательского ввода текста: если при изменении поля INPUT требуется передавать на сервер текущее введенное значение, это может создать большое количество однотипных запросов, особенно если пользователь печатает очень быстро. В этом случае тоже весьма кстати будет ограничить число вызовов обработчика с помощью debounce.<br>
  Функция debounce крайне полезна, когда дело доходит до производительности обработчиков событий.
  
  Ссылки:
  * [habr - Декораторы](https://habr.com/ru/post/60957/)
  * [Для чего нужна функция debounce и как она работает](http://gdrw.ru/reviews/tech/debounce-function-in-javascript)
  * [learn.javascript.ru - реализация на js](https://learn.javascript.ru/task/debounce)
  * [7 важных функций JavaScript](https://getinstance.info/articles/javascript/essential-javascript-functions/)
    
  <br></p></details>
  
  
  <details><summary><b>Мемоизация</b></summary><p>
      
  Разновидность кэширования.
  
  Запоминаем предыдущие результаты вызова функции, и если вызывается снова - используем их из кэша
  
  Для того, чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой, всегда возвращать одни и те же значения в ответ на одни и те же аргументы.
 
 Мемоизация — это компромисс между производительностью и потреблением памяти. Мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти.
 
 Может показаться, что собственные реализации мемоизации стоит применять, например, при обращениях к неким API из браузерного кода. Однако, делать этого не нужно, так как браузер автоматически кэширует их, используя, в частности, HTTP-кэш.
 
 Если вы работаете с React/Redux, можете взглянуть на reselect. Тут используется селектор с мемоизацией. Это позволяет выполнять вычисления только в том случае, если в соответствующей части дерева состояний произошли изменения.
 
 Пожалуй, лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, ресурсоёмкие вычисления. Здесь данная техника может значительно повысить производительность решения. Надо отметить, что нечто вроде вычисления факториала или чисел Фибоначчи — это хорошие учебные примеры, но в реальном мире всё гораздо интереснее и сложнее.
  
  Ссылки:
  [https://habr.com/ru/company/ruvds/blog/332384/](https://habr.com/ru/company/ruvds/blog/332384/)
  
  <br></p></details><br>  

## JS - приёмы ##
                                         
  <details><summary><b>_переменная</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной начинается с _ , её не надо менять или читать снаружи объекта.<br>
  Это просто соглашение об именовании, которое напоминает разработчику о том, что переменная (свойство) или метод являются либо private, либо protected, и к ним нельзя получить доступ из-за пределов класса. 
  
  Чтоб делать это - используй специальные методы: 
  * сеттеры (set... - присвоить) 
  * геттеры (get... - получить)
  
  **Ссылки**
  * [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69) 

  <br><p></details>
  
  <details><summary><b>ПЕРЕМЕННАЯ</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной написано ЗАГЛАВНЫМИ, её не надо менять. Это константа.<br>
  
  **Ссылки**   
  * [learn.js](https://learn.javascript.ru/variables)      
  * [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)
   
  <br><p></details>
  
  <details><summary><b>Переменная</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной начинается с заглавной, значит это не переменная а класс ООП.<br>
  У класса есть методы и всё такое...
     
  **Ссылки**
  * [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69) 
  
  <br><p></details>
              
  <details><summary><b>true && expression</b></summary><p>
    
  `true && expression</b>` - всегда вычисляется как expression, 
    
  `false && expression` - всегда вычисляется как false.
    
  <br></p></details>
  
  <details>
    <summary><b>Math.ceil(x)</b> - метод, округляет x в большую сторону</summary><p>
    
  **Ссылки:**
  - [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)
  
  <br></p></details>
  
  <details><summary><b>Console.log</b></summary><p>
  
  Брайзер добавляет глобальную переменную с именем «console» к каждой загруженной веб-странице. Объект содержит много методов, которые возволят писать на консоль и показывать информацию, проходящую через скрипты.
  
  **Console.dir(object)**<br>
  Позволяет смотреть в консоли свойства заданного javascript объекта.<br>
  Также когда нужно как-то указать в логах на DOM-узел - лучшего всего использовать методы console.dir() или console.dirxml(). Они могут перечислить свойства элемента или вывести HTML кода элемента.
  
  При помощи метода console.dir() можно вывести список всех свойств объекта. Выглядит аналогично тому, что Вы бы увидели во вкладке DOM.
   
  **Группировка**<br>
  Иногда бывает полезно сгруппировать логи для упрощения работы с ними. 
  - console.group()
  - console.groupCollapsed()
  - console.groupEnd()
  ```
    console.group("Overlord");
    console.log("Overlord stuff");
     
    console.group("Lord");
    console.log("Overlord stuff");
     
    console.group("Minion");
    console.log("Minion stuff");
    console.groupEnd();
     
    console.groupCollapsed("Servant");
    console.log("Servant stuff");
  ```
  
  **Раскраска**<br>
  Методы подобные log, но отличающихся внешне: 
  - console.info()
  - console.warn() 
  - console.error()
  
  **Шаблонные строки**<br> 
  console.log(\`Значение переменной = ${var_name}\`)
  
  **Профилирование и замеры**<br>
  Консоль позволяет точно замерять время, используя метод console.time() и console.timeEnd(). Расположите вызов первого из них перед кодом, время исполнения которого хотите замерить, а второго — после.
  ```
  console.time("Execution time took");
  // Some code to execute
  console.timeEnd("Execution time took");
  ```
  Таймеры связаны между собой метками (передаются первым аргументом и могут быть любой строкой), так что Вы можете запустить несколько таймеров одновременно. Когда сработает console.timeEnd(), будет выведено сообщение с меткой и прошедшим временем в миллисекундах.
  
  Помимо замера времени можно профилировать Ваш код и вывести стек профилирования, который подробно показывает, где и сколько времени потратил браузер.
  ```
  console.profile();
  // Some code to execute
  console.profileEnd();
  ```
  
  **Assert**
  Полезно при работе с unit-тестами.
  
  Assert'ы позволяют обеспечивать соблюдение правил в коде и быть уверенным, что результаты выполнения этого кода соответствуют ожиданиям. Метод console.assert() позволяет проводить элементарное тестирование кода: если что-то пойдет не так, будет выброшено исключение. Первым аргументом может быть все, что угодно: функция, проверка на равенство или проверка существования объекта.
  ```
  var a = 1, b = "1";
  console.assert(a === b, "A doesn't equal B");
  ```
  Метод assert принимает условие, которое является обязательным к выполнению (в данном случае простая строгая проверка на равенство) и, вторым аргументом, сообщение, которое будет выведено в консоль вместе с выброшенным исключением, если первое условие не будет выполнено.
  
  **Console.trace()**<br>
  Вывод стека вызовов до текущего момента. Скажет, какие функции есть в стеке, и какие аргументы были переданы каждой. 
  
 
  **Ещё есть** 
  - console.clear - очищает консоль
  - console.count - выводит, сколько раз данный код был выполнен.
  - console.dirxml - выводит XML код элемента
  - console.exception - выводит ошибку и результат trace() для места, откуда она была вызвана
  - console.table - выводит таблицу ([Подробнее](http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/))
  - console.timeStamp - выводит текущий timestamp с текстом, который был передан в name.

  
  **Ссылки:**
  - [habr - Используем console на полную](https://habr.com/ru/post/114483/)
  - [habr - FireBug* Console API](https://habr.com/ru/post/188066/)
  - [learn.javascript.ru - строки-шаблоны](https://learn.javascript.ru/es-string)
  - [MDN - console.dir](https://developer.mozilla.org/ru/docs/Web/API/console/dir)
  - [MDN - console.trace](https://habr.com/ru/post/141042/)
  - [Про console.table (en)](http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/)
    
  <br></p></details>
  
  <details><summary><b>Чистота кода</b></summary><p>
  
  **Общее**
  - Форматирование кода направлено на передачу информации, а передача информации является первоочередной задачей профессионального разработчика.
  - Фигурные скобки в одном стиле
  - Кавычки в одном стиле
  - Точка с запятой - ставить
  - Длина строки - 120 символов
  - Отступы горизонтальные - не нарушать структуру
  - Отступы вертикальные - не более 9 строк кода подряд без вертикального отступа.
  - Имя любой сущности должно отвечать на 3 вопроса - "Почему она существует?", "Какие функции выполняет?", "Как она используется?"
  - Имя переменной – существительное.
  - Имя функции – глагол или начинается с глагола.
  - Уровней вложенности должно быть немного.
  - Вначале код, под ним функции
  - Большие функции дробить на мелкие
  - Функции = Комментарии
  - Разумные комментарии - не "Что делает?", а "Как устроено?", "Какие параметры принимает?", "Почему выбрано это решение?".
  - Принцип единственной обязанности
  - Разделение команд и запросов - не смешивать функции, выполняющие запросы (например, получить имя) и функции выполняющие команды (например, привести имя к нижнему регистру)
  - Слабое *связывание* - это хорошо, сильное - плохо. Сильное связывание = сильная зависимость разных частей программы друг от друга.
  - Высокий ровень *связности* - хорошо (не путать с сильным связыванием). Низкий - плохо. Высокий - сбор конструкций, объединённых общей идеей, в одном месте.
  - Изоляция кода - выделять фрагменты кода в отдельные блоки, основываясь на их предназначении. В качестве таких блоков обычно выступают функции.
  - Разбивка кода на модули - функции, которые используются похожим образом или выполняют похожие действия, можно сгруппировать в одном модуле (или, если хотите, в отдельном классе).
  - Признак слаженности команды - читая код, ты не можешь понять, написал его ты, или коллега
  
  **Конкретика**
  - Вместо == использовать ===
  - Избегать "магических чисел"
  - Имя переменной должно раскрывать её сущность
  - Чем меньше у функции аргументов — тем лучше (**спорно**). Например, её будет легче тестировать. С другой стороны: если у функции N параметров, по первой строчке её объявления сразу видно - что нужно ей передать. Но, больше 5-6 параметров - перебор
  - если функции нужно более 5-6 парамтеров - стоит подумать об использовании объекта с параметрами.
  - Используйте аргументы по умолчанию, отдавая им предпочтение перед условными конструкциями
  - Используйте Object.assign для установки свойств объектов по умолчанию
  - Не используйте флаги в качестве параметров (isOpen и т.д.). Их использование означает, что функция выполняет больше действий, чем следует.
  - Не загрязняйте глобальную область видимости
  - Не называть логические переменные так, чтобы в их именах присутствовало бы отрицание (notAdmin -> isAdmin)
  - Избегайте логических конструкций везде, где возможно. Вместо них используйте полиморфизм и наследование
  - ES-классы стоит предпочесть обычным функциям-конструкторам
  - Организуйте методы так, чтобы их можно было бы объединять в цепочки - в конце каждой из функций класса нужно возвращать this
  - Удаляйте неиспользуемый код
  - Если описывая, что должна делать функция, вы используете союз «и» - эта функция слишком сложна
  - Функция должна решать одну задачу
  - Большие функции стоит перерабатывать в классы. Если функция решает много задач, сильно связаных друг с другом, в которых используются одни и те же данные - имеет смысл переделать её в объект с методами
  - Если имя функции отвечает на некий вопрос - она должна возвращать значение, а не менять состояние данных.
  - Если имя функция "что-то делает" - она должна менять данные и не должна ничего возвращать
  - Жёстко заданные ID в функциях - признак сильного связывания
  - Несколько сильно завиясщих друг от друга функций, по сути = одна большая, просто разделённая на части. Избегай этого
  - Если возникла необходимость модифицировать класс из-за изменений другого класса - это признак сильного связывания
  - Если несколько функций используют одни и те же переменные - они должны быть сгруппированы. Хороший повод объединить их в объект.
  - Одна и та же строка кода не должна повторяться дважды. Повторяющийся код — это надёжный признак низкого уровня связности. Плохо.
  - Одни и те же данные не должны храниться в более чем одной переменной. Если определяете переменные с одинаковыми данными в разных местах программы - используйте класс. 
  - Если вы передаёте ссылку на один HTML-элемент в несколько функций - можно сделать ссылку частью экземпляра некоего класса.
  - Не стоит собирать в одном классе сущности, не имеющие друг к другу никакого отношения.
  - Если свойства не используются несколькими методами класса, это может быть признаком низкого уровня связности. Плохо.
  - Если методы нельзя использовать в различных ситуациях (или метод вообще не используется) — признак плохой связности. Плохо.
  - Возвращать что-либо из функций нужно с помощью ключевого слова return.
  - Для экспорта самых важных сущностей, объявленных в модуле, используйте возможности экспорта по умолчанию. Для второстепенных сущностей можно применить именованный экспорт.
  - Используйте деструктурирование
  - Задавайте стандартные значения параметров функций
  - Не передавайте функциям ненужные данные
  - Ограничивайте размер файла. 100 строк - хорошо. 200-300 - приемлемо. Более 400 - не надо
  - Вложенность кода не должна превышать четырёх уровней.
  - Имена массивов. Массивы обычно содержат в себе наборы каких-то значений. В результате к имени переменной, хранящей массив, имеет смысл добавлять букву s. (student*s*)
  - Имен алогических значений - имеет смысл начинать с is или has.
  - Имена параметров функций, передаваемых стандартным методам массивов - лучше называть с учётом данных, которые в них оказываются 
  - Использование коллбэков ухудшает читабельность кода. Особенно это касается вложенных коллбэков. Где возможно - используйте конструкцию async/await
  - Подчищать за собой console.log. Лишние выводы захламляют консоль. Использование отладочного кода может негативно сказаться на производительности. Но, некоторые логи имеет смысл оставлять. Например — команды, выводящие сообщения об ошибках и предупреждения.
  - Классы не должны быть длиннее 100 строк кода.
  - Методы и функции не должны быть длиннее 5 строк кода.
  - Методам следует передавать не более 4 параметров.
  - Контроллеры могут инициализировать лишь один объект.

  **Книги**
  - Макконелл С - Совершенный код
  
  **Руководства по стилю**
  - [Google JavaScript Style Guide (en)](https://google.github.io/styleguide/jsguide.html)
  - [jQuery JavaScript Style Guide (en)](http://contribute.jquery.org/style-guide/js/)
  - [Airbnb JavaScript Style Guide (en)](https://github.com/airbnb/javascript) 
  - [Airbnb JavaScript Style Guide (ru)](https://github.com/leonidlebedev/javascript-airbnb)
  - [Idiomatic.JS (en)](https://github.com/rwaldron/idiomatic.js) 
  - [Idiomatic.JS (ru)](https://github.com/rwaldron/idiomatic.js/tree/master/translations/ru_RU)
  - [Dojo Style Guide (en)](https://dojotoolkit.org/reference-guide/1.10/developer/styleguide.html)
  - [JSLint style (en)](https://www.jslint.com/help.html)

  **Автоматизированные средства проверки (линтеры)**
  - [JSLint](http://www.jslint.com/)
  - [JSHint ](http://www.jshint.com/) - вариант JSLint с б*о*льшим количеством настроек

  **Ссылки**
  - [learnjavascript - Как писать неподдерживаемый код?](https://learn.javascript.ru/write-unmain-code)
  - [learnjavascript - Советы по стилю кода](https://learn.javascript.ru/coding-style)
  - [habr - Рекомендации по написанию чистого кода на JavaScript](https://habr.com/ru/company/ruvds/blog/454520/)
  - [habr - JavaScript: путь к ясности кода](https://habr.com/ru/company/ruvds/blog/342404/)
  - [habr - 7 рекомендаций по оформлению кода на JavaScript](https://habr.com/ru/company/ruvds/blog/418631/)
  - [habr - Как писать чистый и красивый код](https://habr.com/ru/company/ruvds/blog/347610/)
  - [habr - Пишем чистый и масштабируемый JavaScript-код: 12 советов](https://habr.com/ru/company/ruvds/blog/452562/)
  - [YouTube - Доклад Сэнди Метц о 4 правилах написания чистого кода в объектно-ориентированных языках (en)](https://www.youtube.com/watch?v=npOGOmkxuio)
  
  <br></p></details>
  

#
<details><summary><b>JS - история версий</b></summary><p>

  ---
  <details><summary><b>История версий ES</b></summary><p>
    
  JavaScript создавался как скриптовый язык для Netscape. Изначально разработкой занимались Брендан Эйх, Марк Андрессен и Билл Джой.<br>
  После чего он был отправлен в ECMA International для стандартизации (ECMA — это ассоциация, деятельность которой посвящена стандартизации информационных и коммуникационных технологий). Стандартизированная версия имеет название ECMAScript, описывается стандартом ECMA-262.
  
  ECMAScript — стандарт, а JavaScript — самая популярная реализация этого стандарта.</br>
  Среди других реализаций можно отметить SpiderMonkey, V8 и ActionScript.
      
  ECMAScript - стандарт, развивается и поддерживается ассоциацией [ECMA International](http://www.ecma-international.org/memento/index.html). Ecma International Technical Committee 39 (он же TC39) — комитет очень умных людей :) Задача TC39 - поддержка и обновление спецификации ECMAScript, после обсуждения и всеобщего согласия. Сюда относятся синтаксис языка, семантика, библиотеки и сопутствующие технологии, на которых основывается язык. 
  
  С 2015 года принято решение обновлять язык ежегодно.<br>
  ES.Next - термин является динамическим и автоматически ссылается на новую версию ECMAScript. 
      
  * ES1 - 1997
  * ES2 - 1998
  * ES3 - 1999
  * ES4 - не выпущена
  * ES5 - 2009
  * ES6 - 2015
  * ES7 - 2016
  * ES8 - 2017
  * ES9 - 2018
      
  **Ссылки**
  * [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
  * [Официальная спецификация - актуальная (en)](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
  * [Официальная спецификация - архив (en)](https://www.ecma-international.org/publications/standards/Ecma-262-arch.htm)
  * [Разъяснения насчёт JavaScript, ECMA–262, TC39 и транскомпиляторов ECMAScript](https://www.frontender.info/javascript-ecma-262-tc39-and-ecmascript-transpilers-explained/)
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

  <br></p></details>
  
  <details><summary><b>ES9 (ECMAScript 2018 )</b></summary><p>
    
  * <b>Разделяемая память (shared memory) и атомарные операции (atomics)</b> - касается ядра JS-движков. Позволяет писать высокопроизводительные параллельные приложения, дает возможность управлять памятью самостоятельно, не отдавая выполнение всех аспектов этой задачи JS-движку.
  * <b>Оператора rest</b> - выглядит как три точки. Позволяет извлекать свойства объекта. Используется в левой части выражения.
  * <b>Оператор spread</b> - тоже выглядит как три точки. Используется для создания новых объектов. Используется в правой части выражения со знаком присваивания.
  * <b>Асинхронная итерация, цикл for-await-of</b> - позволяет создавать циклы, работающие с асинхронным кодом. Добавляется новый оператор цикла вида <b>for-await-of</b>, который позволяет вызывать асинхронные функции, возвращающие промисы (или обрабатывать массивы, содержащие промисы) в цикле.
  * <b>Метод finally()</b> — это новый метод объектов Promise. Позволяет выполнять функцию обратного вызова после resolve() или reject(), чтобы корректно завершать операции (например, высвобождая ресурсы).
   * <b>Устранение ограничений тегированных шаблонных строк</b> - больше свободы, что писать в шаблонных строках.
  * <b>Регулярки. Флаг dotAll</b> - изменили настройки регулярок. Чтоб работать в новом формате - устанавливаем спец. флаг.
  * <b>Регулярки. Захват именованных групп</b> - позволяет писать регулярные выражения с назначением имён (идентификаторов) для групп. Облегчает работу с группами.
  * <b>Регулярки. Ретроспективная проверка</b> - позволяет узнать, существует ли некая строка сразу перед некоторой другой строкой.
  * <b>Регулярки. Улучшена поддержка Unicode</b> - можно использовать спец. конструкцию для поиска символов не-латинских языков(хинди, греческий...)
  
  **Ссылки**
  * [Официальная спецификация (en)](http://www.ecma-international.org/publications/standards/Ecma-262.htm)
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)
  * [Что нового в ES2018 JavaScript](https://webformyself.com/chto-novogo-v-es2018-javascript/)

  <br></p></details>

  <details><summary><b>ES8 (ECMAScript 2017)</b></summary><p>
  
  * <b>Конструкция Async/Await</b> - асинхронные функции, работают на основе promise 
  * <b>Метод Object.values()</b> - возвращает все значения собственных свойств объекта, исключая любые значения в цепочке прототипов.
  * <b>Меотд Object.entries()</b> - похож на метод Object.keys(), но вместо того, чтобы возвращать лишь ключи, он возвращает, в виде массива, и ключи, и значения. Упрощает выполнение операций c объектами в циклах, или преобразование обычных объектов в объекты типа Map.
  * <b>Методы дополнения строк до заданной длины</b> - String.prototype.padStart() и String.prototype.padEnd().
  * <b>Метод Object.getOwnPropertyDescriptors()</b> -  возвращает все сведения (включая данные о геттерах и сеттерах) для всех свойств заданного объекта. Позволяет создавать мелкие копии объектов и клонировать объекты, создавая новые объекты, при этом копируя, помимо прочего, геттеры и сеттеры. 
  * Теперь можно ставить <b>завершающие запятые</b> после последнего параметра функции
    
  **Ссылки**
  * [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/8.0/index.html)      
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)  

  <br></p></details>
  
  <details><summary><b>ES7 (ECMAScript 2016)</b></summary><p>
      
  * <b>Метод Array.prototype.includes()</b> - метод объектов типа Array, который позволяет выяснить, имеется ли в массиве некий элемен. <br>
  * <b>Оператор возведения в степень</b> - **. Заменяет Math.pow().
      
  **Ссылки**
  * [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/7.0/index.html)     
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

  <br></p></details>
  
  <details><summary><b>ES6 (ECMAScript 2015)</b></summary><p>
      
  * [Переменные: let и const](https://learn.javascript.ru/let-const)
  * [Деструктуризация](https://learn.javascript.ru/destructuring)
  * [Функции](https://learn.javascript.ru/es-function)
  * [Строки](https://learn.javascript.ru/es-string) - введены шаблоны, улучшена поддержка Unicode, добавлены методы
  * [Объекты и прототипы](https://learn.javascript.ru/es-object)
  * [Классы](https://learn.javascript.ru/es-class)
  * [Тип данных Symbol](https://learn.javascript.ru/symbol) - для создания уникальных идентификаторов
  * [Итераторы](https://learn.javascript.ru/iterator) - можно сделать "перебираемым любой" объект
  * [Set, Map, WeakSet и WeakMap](https://learn.javascript.ru/set-map) - новые типы коллекций
  * [Promise](https://learn.javascript.ru/promise) - способ организации асинхронного кода/p>
  * [Генераторы](https://learn.javascript.ru/generator) - новый вид функций. Могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять выполнение позже.
  * [Модули](https://learn.javascript.ru/modules) - введён официальный стандрат поддержки модулей в JS
  * [Proxy](https://learn.javascript.ru/proxy) - особый объект, перехватывает обращения к другому объекту и, при необходимости, модифицирует их.
  
  **Ссылки**
  * [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/6.0/index.html) 
  * [learn.js](https://learn.javascript.ru/es-modern)
  * [code.mu](http://code.mu/books/javascript/advanced/novovvedeniya-v-es6-dlya-novichkov.html)  
    
  <br></p></details>
  
  <details><summary><b>ES5 (ECMAScript 2009)</b></summary><p>
    
  Среди изменений:
  * поддержку строгого режима (strict mode);
  * аксессоры getters и setters;
  * возможность использовать зарезервированные слова в качестве ключей свойств и ставить запятые в конце массива;
  * многострочные строковые литералы;
  * поддержка JSON.
    
  **Ссылки**
  * [Официальная спецификация (en)](http://ecma-international.org/ecma-262/5.1/)
  * [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
  * [ES5 руководство по JavaScript](https://habr.com/ru/post/281110/)
  * [Перевод спецификации EcmaScript 5 с аннотациями](https://es5.javascript.ru/)
  
  <br></p></details>
  
  <details><summary><b>Языки поверх JavaScript</b></summary><p>
    
  Синтаксис JavaScript устраивает не всех - одним он кажется слишком свободным, другим слишком ограниченным, третьи хотят добавить дополнительные возможности…
      
  Появилось много языков, которые добавляют различные возможности «поверх» JavaScript. Для запуска в браузере они превращаются в обычный JS-код (при помощи специальных инструментов «трансляторов»).
    
  Это преобразование происходит автоматически и совершенно прозрачно, при этом неудобств в разработке и отладке практически нет.
    
  Разные языки выглядят по-разному и добавляют разные вещи:
  - **CoffeeScript** – «синтаксический сахар» поверх JavaScript. Сосредоточен на большей ясности и краткости кода. Часто его любят программисты на Ruby.
  - **TypeScript** - сосредоточен на добавлении строгой типизации данных. Предназначен для упрощения разработки и поддержки больших систем. Разрабатывается Microsoft.
  - **Dart** - не только транслируется в JS, но имеет и свою независимую среду выполнения, которая даёт ему ряд возможностей и доступна для встраивания в приложения (вне браузера). Разрабатывается компанией Google.
  
  **Ссылки:**
  * [learn.javascript.ru](https://learn.javascript.ru/intro)
  
  <br></p></details>
<br></p></details>
 


*[Legmo, 2019](https://github.com/Legmo/notes/)*