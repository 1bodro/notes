# Шпаргалка по общим вопросам программирования и frontend-разработки #

#
<details><summary><b>AJAX, JSON, CORS и т.д.</b></summary><p>
  
  ---
  <details><summary>Порт — это номер, который, выдаёт операционная система каждой программе, которая хочет отослать данные в сеть</summary>
  </details>
  
  <details><summary>TCP/IP - сетевая модель передачи данных, представленных в цифровом виде.</summary>
      T.е. теоретическое описание принципов работы набора сетевых протоколов, взаимодействующих друг с другом. 
      
      В модели предполагается прохождение информации через четыре уровня, каждый из которых описывается правилом (протоколом передачи). Наборы правил, решающих задачу по передаче данных, составляют стек протоколов передачи данных, на которых базируется Интернет[1][2]. 
  
      Название TCP/IP происходит из двух важнейших протоколов семейства — Transmission Control Protocol (TCP) и Internet Protocol (IP), которые были первыми разработаны и описаны в данном стандарте. 
  
  
      В протоколе Ethernet находятся номер сетевого адаптера отправителя (MAC-адрес), номер сетевого адаптера получателя, тип передаваемых данных и непосредственно передаваемые данные. Порция информации, составленная в соответствии с протоколом Ethernet, называется кадром. Считается, что сетевых адаптеров с одинаковым номером не существует. Сетевое оборудование извлекает передаваемые данные из кадра (аппаратно или программно), и производит дальнейшую обработку.
  
      Как правило, извлечённые данные в свою очередь сформированы в соответствии с протоколом IP и имеют другой вид идентификационной информации — ip адрес получателя (число размером в 4 байта), ip адрес отправителя и данные. А так же много другой необходимой служебной информации. Данные, сформированные в соответствии с IP протоколом, называются пакетами.
  
      Далее извлекаются данные из пакета. Но и эти данные, как правило, ещё не являются изначально отправляемыми данными. Этот кусок информации тоже составлен в соответствии определённому протоколу. Наиболее широко используется TCP протокол. В нём содержится такая идентификационная информация, как порт отправителя (число размером в два байта) и порт источника, а так же данные и служебная информация. Извлечённые данные из TCP, как правило, и есть те данные, которые программа, работающая на компьютере В, отправляла «программе-приёмнику» на компьютере A.
  
      Вложенность протоколов (в данном случае TCP поверх IP поверх Ethernet) называется стеком протоколов.
  
      Фактически TCP/IP не один протокол, а несколько. Именно поэтому вы часто слышите, как его называют набором, или комплектом протоколов, среди которых TCP и IP - два основных. 
  
      https://habr.com/ru/post/326574/
      https://ru.wikipedia.org/wiki/TCP/IP
  </details>
  
  <details><summary>HTTP - протокол передачи данных</summary>
      HyperText Transfer Protocol, «протокол передачи гипертекста»
  
      Протокол прикладного уровня (верхний 7-й уровень модел OSI) предназначенный для передачи произвольных данных при клиент-серверном взаимодействии.
  
      предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.
  
      HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как SOAP, XML-RPC и WebDAV. В таком случае говорят, что протокол HTTP используется как «транспорт».
  
      API многих программных продуктов также подразумевает использование HTTP для передачи данных — сами данные при этом могут иметь любой формат, например, XML или JSON.
  
      Как правило, передача данных по протоколу HTTP осуществляется через TCP/IP-соединения.
  </details>
  
  <details><summary>HTTPS - распространённое расширение HTTP, которое реализует упаковку передаваемых данных в криптографический протокол SSL или TLS.</summary>
      
      Методы HTTP-протокола:
        Метод — это указание операции над ресурсом.
          - GET — получение данных с ресурса. Не имеет тела, информацию можно передать только через querystring. Кэшируется.
          - HEAD — как GET но не возвращает данных. Используют для проверки существования сайта, получения метаданных. Кэшируется.
          - POST — отправка данных к ресурсу. Не кэшируется.
          - PUT — замещение данных ресурса. Не кэшируется.
          - DELETE — удаление данных ресурса. Не кэшируется.
          - OPTIONS — предварительный запрос к серверу при кросс-доменном запросе. Не кэшируется (???).
  
      https://habr.com/ru/post/215117/
  </details>
  
  <details><summary>JSON (Javascript Object Notation) - формат данных, который используется для представления объектов в виде строки.</summary>
      Если нужно с сервера взять объект с данными и передать его клиенту, то в качестве промежуточного формата – для передачи по сети, почти всегда используют именно его.
  
      Данные в формате JSON (RFC 4627) представляют собой:
          - JS-объекты { ... } или
          - Массивы    [ ... ] или
          - Значения одного из типов:
              - строки в двойных кавычках,
              - число,
              - логическое значение true/false,
              - null.
  
      https://learn.javascript.ru/json
  </details>
  
  <details><summary>AJAX - технология отправки запросов к серверу из клиентского кода JavaScript без перезагрузки страницы.</summary>
        https://learn.javascript.ru/ajax
        https://habr.com/ru/post/14246/
  
        Расшифровывается как Asynchronous JavaScript And XML. 
        Сейчас вместо чаще XML используют формат JSON.
        Слать AJAX-запросы к серверам с другим доменом запрещено на уровне браузера. Ajax не кроссдоменный, но подходит много для каких задач.
        Асинхронный
        Браузер предоставляет для AJAX специальный API: конструктор XMLHttpRequest
        AJAX работает через XMLHttpRequest (XMLHTTP, XHR), т.е. через запросы HTTP/HTTPS 
        Т.е. асинхронный обмен данными (JSON/XML/TXT) через HTTP/HTTPS запросы
  
        При использовании AJAX:
          - Пользователь заходит на веб-страницу и нажимает на какой-нибудь её элемент.
          - Скрипт (на языке JavaScript) определяет, какая информация необходима для обновления страницы.
          - Браузер отправляет соответствующий запрос на сервер.
          - Сервер возвращает только ту часть документа, на которую пришёл запрос.
          - Скрипт вносит изменения с учётом полученной информации (без полной перезагрузки страницы).
  
        AJAX использует два метода работы с веб-страницей: 
          - изменение Web-страницы без перезагрузки, используя DHTML (совокупность технологий CSS, DOM и JavaScript)
          - динамическое обращение к серверу. Может осуществляться несколькими способами, в частности, XMLHttpRequest, и использование техники скрытого фрейма.
  
      Алгоритм запроса к серверу выглядит так:
          - Проверка существования на странице объекта XMLHttpRequest. Создание данного объекта для каждого типа браузера — уникальный процесс.
          - Инициализация соединения с сервером.
          - Посылка запроса серверу (GET или POST)
          - Обработка полученных данных.
  
        От сервера можно получить данные нескольких видов:
          - Обычный текст
          - XML
          - JSON
  
        Альтернативы AJAX:
          - Java-апплеты, позднее технология JavaFX;
          - Технология Silverlight корпорации Microsoft;
          - Протокол WebSocket.
  </details>
  
  <details><summary>JSONP (JSON with Padding, JSON с набивкой) - протокол. Дополнение к формату JSON. Способ запросить данные с сервера, находящегося в другом домене.</summary>
      Не имеет отношения к AJAX
      Устаревший но хитрый способ двунаправленного кроссдоменного взаимодействия, основанный на загрузке скрипта с другого домена.
      В частности, с помощью протокла JSONP можно организовать некоторые разновидности технологии COMET. 
      Насколько я понимаю, работает также с использование XMLHttpRequest, т.е. поверх HTTP/HTTPS
  
      Согласно политике ограничения домена, веб-страница, расположенная на сервере server1.example.com, не может связаться с сервером, отличным от server1.example.com. Эта операция запрещена в большинстве браузеров.
  
      Идея основана на лазейке в стандартах: загружать скрипты с других доменов не запрещено!
  
      <!--
      В основу технологии JSONP положен тот факт, что политика безопасности браузера не запрещает использовать HTML-элемент <script type="text/javascript" src="…"/> для обращения к серверам, отличным от сервера, с которого произошла загрузка страницы. Используя открытую политику для элементов <script>, некоторые страницы используют их, чтобы загружать JavaScript-код, оперирующий динамически создаваемыми JSON-данными из других источников. 
  -->
      Запросы для JSONP получают не JSON, а произвольный JavaScript-код. Они обрабатываются интерпретатором JavaScript, а не парсером JSON.
  
      Существуют серьезные риски, связанные с безопасностью при использовании JSONP, в большинстве ситуаций использование CORS является лучшим выбором.
  
      JSONP кроссдоменный, но подходит только для случаев, когда надо кроссдоменно передать JSON.
  
      Набивка (префикс) 
        Набивка обычно является именем функции обратного вызова, определённой внутри контекста выполнения в браузере. Кроме имени функции префикс может означать имя переменной, оператор if, или любой другой оператор JavaScript. Ответ на JSONP-запрос (строго говоря — запрос, соответствующий паттерну JSONP) не является объектом JSON и не расценивается браузером, как таковой. «Начинка» может быть любым выражением на JavaScript, и вовсе не требует, чтобы внутри обязательно был JSON. Но обычно это фрагмент JavaScript, применяющий вызов функции к неким JSON-данным.
  
        Другими словами, типичное применение JSONP предоставляет междоменный доступ к существующему JSON API путём оборачивания начинки JSON в вызов функции.
  
      Недостатки
        - Прежде всего, это лазейка, костыль. Разработчики стандартов просто не были настолько хитры, чтобы предугадать динамическое взаимодействие на уровне скриптов.
  
        - Безопасность. Подгрузка скриптов ни разу не безопасней, чем Аякс. Целое семейство вирусов занимается тем, что добавляет на страницу браузера скрипты для отрисовки баннеров порно и казино. Когда вы подключаетесь к интернету через мобильных операторов, обсосы вставляют в HTML-трафик скрипты для отрисовки виджетов (если соединение не HTTPS)
  
        - Только GET. JSONP работает только методом GET, что сводит на нет возможности REST-интерфейса. Для REST-сервисов приходится писать прокладки-прокси, т.е. множить костыли. Неустранимое ограничение — позволяет только получение данных GET методом, то есть отправка данных через POST метод остается недоступной. 
  
        - Нельзя отслеживать. Добавив скрипт на страницу, в дальнейшем вы не можете отследить его судьбу. Если у Аякс-запроса есть специальные коллбеки для основных событий (начало, удачное завершение, таймаут, неудачное завершение), то у скрипта ничего такого нет. Загрузился ли он? Ответил ли сервер? Была ли ошибка? Никто не знает.
  
      Каковы проблемы JSONP?
          - Это вне стандартов.
          - Это небезопасно.
          - Если запрос провалился, то ничего мы никогда не узнаем, не обработаем ошибку правильно, не можем отследить судьбу запроса.
          - Мы работаем только с GET — никаких модных REST API.
          - И в общем, так делать не надо в 2017 году.
  
      Приложениям на js нужен надежный способ забирать данные с серверов. Чтобы это была законно, а не по-воровски в обход протоколов и стандартов. Таким способом стал CORS – Cross-Origin Resource Sharing, кросс-доменные запросы.
  
      https://ru.wikipedia.org/wiki/JSONP
      https://grishaev.me/cors/
  </details>
  
  <details><summary>JSONPP (англ. parameterized JSON with padding — «параметризованный JSON с подкладкой») — развитие идеи JSONP</summary>
      развитие идеи JSONP
      включает в себя URL источника, имя функции, которая будет обрабатывать JSON данные, строка для eval после получения данных и строка для eval после окончания обработки данных
  </details>
  
  <details><summary>CORS - кросс-доменные запросы. Разрешаем кросс-доменный AJAX (если сервер согласен его принять)</summary>
      Cross-origin resource sharing (англ. — «совместное использование ресурсов между разными источниками») 
      Технология современных браузеров, которая позволяет предоставить веб-странице доступ к ресурсам другого домена. Современный стандарт кроссдоменных запросов
      Слать AJAX-запросы к серверам с другим доменом запрещено на уровне браузера
      Фактически - расширение поверх AJAX
  
      Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. 
      Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
  
      Здесь: 
        - клиент шлет Аякс-запрос к чужому серверу. 
        - браузер добавляет в запрос особые заголовки с информацией о том, что запрос с другого домена. 
        - на их основании сервер решает, как обрабатывать такой запрос, и добавляет особые заголовки в ответ
  
      Браузер добавит заголовок Origin с адресом страницы, откуда инициирован запрос. Подделать заголовок скриптом не удастся
  
      Т.е. по факту я в своём приложении создаю AJAX запрос с опр. набором параметров (заголовки и т.д.), и если сервер поддерживает CORS - он пришлёт ответ
  
      Простые и сложные CORS-запросы
        - Сложные идут в два этапа (preflight запрос и собственно запрос). Сначала браузер делает запрос по тому же урлу, но методом OPTIONS. Сервер должен ответить: какими другими методами и дополнительными заголовками (помимо стандартных) можно обращаться к этому урлу. И только получив разрешение, браузер сделает запрос на основной урл.
        - Запрашиваешь JSON - автоматически должен использовать сложный запрос
  
      Поддержка браузерами
          - Firefox 3.5 и выше
          - Google Chrome 3 и выше
          - Opera 12.00
          - Safari 4 и выше
          - Internet Explorer 
            8      - частичная поддержка через XDomainRequest объект. 
            9      - частичная поддержка через XDomainRequest объект. 
            10 	   - встроенная поддержка
            10,11  - не поддерживают CORS для интернациональных доменных имен (IDN), содержащих нелатинские символы.
  
  
      Технология CORS может быть использована как более современная и надёжная альтернатива JSONP, так как позволяет использовать все преимущества XMLHttpRequest, и не имеет риска инъекции, как JSONP. С другой стороны, технология CORS поддерживается только современными браузерами, а JSONP работает и в старых тоже. 
  
      Механизм CORS поддерживает кросс-доменные запросы и передачу данных между браузером и web-серверами по защищенному соединению. 
      Современные браузеры используют CORS в API-контейнерах, таких как XMLHttpRequest или Fetch, чтобы снизить риски, присущие запросам с других источников.
  
      https://grishaev.me/cors/
      https://ru.wikipedia.org/wiki/Cross-origin_resource_sharing
      https://developer.mozilla.org/ru/docs/Web/HTTP/CORS
  </details>
  
  <details><summary>- COMET – общий термин, описывающий различные техники получения данных по инициативе сервера.</summary>
      Методика отправки данных по инициативе сервера, разработанная поверх AJAX.
      
      Можно сказать, что AJAX – это «отправил запрос – получил результат», а COMET – это «непрерывный канал, по которому приходят данные».
      COMET можно реализовать по протоколу JSONP. Можно и иначе 
      COMET - методика отправки данных по инициативе сервера, разработанная поверх AJAX.
  
      Примеры COMET-приложений:
          - Чат – человек сидит и смотрит, что пишут другие. Новые сообщения приходят «сами по себе», не надо жать кнопку для обновления окна.
          - Аукцион – человек смотрит на экран и видит, как обновляется текущая ставка за товар.
          - Интерфейс редактирования – когда один редактор начинает изменять документ, другие видят информацию об этом. Совместное редактирование.
  
      Какие API предоставляет браузер для взаимодействия COMET?
        - SSE (server-side events) API — события посылаемые сервером — однонаправленное HTTP-подключение к серверу. Поддерживают короткие запросы, длинные запросы, потоковое подключение к серверу.
        - Web Sockets API — двунаправленное взаимодействие с сервером. Работает по собственному протоколу.
  
        Страница не просто разово или циклично запрашивает контент с сервера, а создает с сервером постоянное HTTP-соединение и ждет от него передачи данных. Это позволяет пользователям веб-приложения более оперативно получать все возникающие на сервере события (пример - мгновенное уведомление о новом сообщении в социальных сетях). 
        В идеальном варианте для этого на сервере разворачивается специальное программное обеспечение, сам сервер особым образом конфигурируется, а на клиентской части используются специальные библиотеки для обмена данными. Это если рассматривать использование COMET в контексте больших и серьезных проектов. Для рядового сайта, размещенного на обычном хостинге с ограничением времени исполнения скрипта, можно сделать облегченный аналог COMET.
  
        - polling
          Использование периодических запросов к серверу через AJAX. Например, скрипт из браузера каждые 5 секунд отправляет запрос на серверный скрипт и запрашивает количество новых непрочитанных сообщений. 
          Можно дополнительно снизить нагрузку на сервер путем снижения частоты отсылаемых запросов, но это опять же пойдет в ущерб актуальности данных и в разрез с условием задачи о мгновенном информировании пользователя о письме.
  
        - long polling (это вариант реализации COMET) 
          Есть несколько вариантов реализации, но, к сожалению, практически все они завязаны на конкретном браузере и ведут себя по-своему. 
          Единственным кроссбраузерным и гарантированно работающим решением является так называемая "очередь длинных запросов", или "long polling". 
  
          Сначала браузер отправляет AJAX-запрос на сервер и ожидает ответа. Соединение остается открытым до тех пор, пока на сервере не наступит ожидаемое событие (или, как в нашем случае, пока серверный скрипт не отвалится по таймауту). Сразу после наступления события данные отправляются в браузер и соединение закрывается. Браузер после получения данных сразу же открывает новое соединение и все повторяется. 
  
          Это очень похоже на предыдущий способ "polling", но данные с сервера передаются с максимально возможной актуальностью. Если за время ожидания никаких событий на сервере не случилось, интервал между "долгими" запросами будет гораздо больше, чем при долбежке сервера периодическими опросами. Поэтому еще более минимизируются расходы на передачу заголовков запросов, тем самым еще больше снижается нагрузка на сервер.
  </details>
  
  <details><summary>WebSocket - протокол для пересылки любых данных, на любой домен, безопасно и почти без лишнего сетевого трафика. Замена AJAX.</summary>
      Один из API браузера, который он предоставляет чтоб реализовать COMET. 
      Альтернатива - SSE (server-side events) API.
      
      WebSocket - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени. 
      Предназначен для решения любых задач и снятия ограничений обмена данными между браузером и сервером.
      независимый протокол, основанный на протоколе TCP
      Не стоит использовать веб-сокеты в REST API, поскольку вам хватит таких HTTP-запросов, как GET, POST, DELETE и PUT.
      В отличие от CORS работает вообще без AJAX, отдельный протокол, даже на HTTP
  
      Протокол WebSocket работает над TCP& также как и HTTP. Т.е. на том же уровне, что и HTTP, заменяет его, а не "поверх него"
      AJAX работает на HTTP
      Это означает, что при соединении браузер отправляет по HTTP специальные заголовки, спрашивая: «поддерживает ли сервер WebSocket?».
      Если сервер в ответных заголовках отвечает «да, поддерживаю», то дальше HTTP прекращается и общение идёт на специальном протоколе WebSocket, который уже не имеет с HTTP ничего общего.
  
      Соединение WebSocket можно открывать как WS:// или как WSS://. Протокол WSS представляет собой WebSocket над HTTPS.
      Кроме большей безопасности, у WSS есть важное преимущество перед обычным WS – большая вероятность соединения.
      Дело в том, что HTTPS шифрует трафик от клиента к серверу, а HTTP – нет.
      Если между клиентом и сервером есть прокси, то в случае с HTTP все WebSocket-заголовки и данные передаются через него. Прокси имеет к ним доступ, ведь они никак не шифруются, и может расценить происходящее как нарушение протокола HTTP, обрезать заголовки или оборвать передачу.
      А в случае с WSS весь трафик сразу кодируется и через прокси проходит уже в закодированном виде. Поэтому заголовки гарантированно пройдут, и общая вероятность соединения через WSS выше, чем через WS.
  
      WebSocket поддерживается в следующих браузерах:
          Google Chrome (начиная с версии 4.0.249.0);
          Apple Safari (начиная с версии 5.0.7533.16);
          Mozilla Firefox (начиная с версии 4);
          Opera (начиная с версии 10.70 9067);
          Internet Explorer (начиная с версии 10);
  
          Проверить поддержку браузером WebSocket можно, пройдя по ссылке: http://caniuse.com/#feat=websockets. 
  
        Это сдвиг парадигмы HTTP. Изначально синхронный протокол, построенный по модели «запрос — ответ», становится полностью асинхронным и симметричным. Теперь уже нет клиента и сервера с фиксированными ролями, а есть два равноправных участника обмена данными. Каждый работает сам по себе, и когда надо отправляет данные другому. Отправил — и пошел дальше, ничего ждать не надо. Вторая сторона ответит, когда захочет — может не сразу, а может и вообще не ответит. Протокол дает полную свободу в обмене данными, вам решать как это использовать.
  
        Как только ваша страница решила, что она хочет открыть веб сокет на сервер, она создает специальный javascript-объект WebSocket  и навешивает на новый объект три колл-бека:
          - первый вызовется, когда соединение будет установлено:
          - второй - когда соединено закроется
          - третий - каждый раз, когда браузер получает какие-то данные через веб-сокет
        Браузер подключается по протоколу TCP на 80 порт сервера и дает немного необычный GET-запрос
        Если сервер поддерживает ВебСокеты, то он отвечает опр. образом
        Если браузер это устраивает, то он просто оставляет TCP-соединение открытым. Все — «рукопожатие» совершено, канал обмена данными готов.
        Как только одна сторона хочет передать другой какую-то информацию, она отправляет дата-фрей. Это просто строка текста — последовательность байт. Никаких заголовков, метаданных! Что именно отправлять, разработчики полностью оставили на ваше усмотрение: хотите XML, хотите JSON, да хоть стихи Пушкина.
        Каждый раз, когда браузер будет получать такое сообщение, он будет «дергать» ваш колл-бек onmessage. 
  
        Легко понять, что КПД такого протокола стремится к 95%. Это не классический AJAX-запрос, где на каждую фитюльку приходится пересылать несколько килобайт заголовков. Разница будет особенно заметна если делать частый обмен небольшими блоками данных. Скорость обработки так же стремится к скорости чистого TCP-сокета — ведь все уже готово — соединение открыто — всего лишь байты переслать.
  
        в качестве единственной разрешенной кодировки выбрана UTF-8
  
        А картинку можно отправить? Да. С помощью WebSockets так же можно передавать и бинарные данные. Для них используется другой дата-фрейм опр. вида
  
      Скорость и эффективность
        Высокую скорость и эффективность передачи обеспечивает малый размер передаваемых данных, который иногда даже будет помещаться в один TCP-пакет — здесь, конечно, же все зависит от вашей бизнес-логики. 
        Так же учтите, что соединение уже готово — не надо тратить время и трафик на его установление, хендшейки, переговоры.
  
      Стандартность
        Самим своим выходом WebSockets отправит на свалку истории Comet и все приблуды накрученные поверх него — Bayuex, LongPolling, MultiPart и так далее. Это все полезные технологии, но по большей части, они работают на хаках, а не стандартах. Отсюда периодески возникают проблемы
  
        Время жизни канала
        В отличие от HTTP веб-сокеты не имеют ограничений на время жизни в неактивном состоянии. Это значит, что больше не надо периодически рефрешить соединение, т.к. его не вправе «прихлопывать» всякие прокси. Значит, соединение может висеть в неактивном виде и не требовать ресурсов. Конечно, можно возразить, что на сервере будут забиваться TCP-сокеты. Для этого достаточно использовать хороший мультиплексор, и нормальный сервер легко потянет до миллиона открытых коннектов.
  
      Комплексные веб-приложения
        Как известно в HTTP предусмотрено ограничение на число одновременных октрытых сессий к одному серверу. Из-за этого если у вас много различных асинхронных блоков на странице, то вам приходилось делать не только серверный, но и клиентский мультиплексор — именно отсюда идет Bayeux Protocol.
        К счастью, это ограничение не распространяется на веб-сокеты. Открываете столько, сколько вам нужно. А сколько использовать — одно (и через него все мультиплексировать) или же наоборот — на каждый блок свое соединение — решать вам. Исходите из удобства разработки, нагрузки на сервер и клиент.
  
      Кросс-доменные приложения
        И еще один «камень в ботинке» AJAX-разработчика — проблемы с кросс-доменными приложениями. Да, и для них тоже придумана масса хаков. Помашем им ручкой и смахнем скупую слезу. WebSockets не имеет таких ограничений. Ограничения вводятся не по принципу «из-того-же-источника», а из «разрешенного-источника», и определяются не на клиенте, а на сервере. Думаю, внимательные уже заметили новый заголовок Origin. Через него передается информация откуда хотят подключиться к вашему websocket-у. Если этот адрес вас не устраивает, то вы отказываете в соединение.
        
  
      https://ru.wikipedia.org/wiki/WebSocket
      https://learn.javascript.ru/websockets
      https://blog.securityevaluators.com/websockets-not-bound-by-cors-does-this-mean-2e7819374acc
  </details>
  
  <details><summary>SSE API (server-side events) - события посылаемые сервером, т.е. однонаправленное HTTP-подключение к серверу.</summary>
      Ещё один вариант API, который предоставляет браузер для взаимодействия COMET. 
      Альтернатива WebSocket
  </details>
  
  <details><summary>XMLHttpRequest (XHR) - объект, который дает возможность браузеру из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.</summary>
      https://learn.javascript.ru/ajax-xmlhttprequest
      - Все современные браузеры (IE7+, Firefox, Chrome, Safari и Opera) имеют встроенный объект XMLHttpRequest.
      - Может работать с синхронными и асинхронными запросами
      - Как правило, XMLHttpRequest используют для загрузки данных.
  </details>
  
  <details><summary>Метод fetch - встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest.</summary>
      https://learn.javascript.ru/fetch
      Большинство браузеров уже поддерживает fetch – новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. 
      Он гораздо мощнее, чем httpGet. 
      Этот метод использует промисы. 
      Возвращает промис, который, когда получен ответ, выполняет коллбэки с объектом Response или с ошибкой, если запрос не удался.
  </details>
  
  <details><summary>DHTML (англ. Dynamic HTML) - совокупность технологий CSS, DOM и JavaScript</summary>
  </details>
  
  **Ссылки**
  - [Сети в вопросах и ответах. HTTP-протокол. AJAX. JSONP. CORS.COMET](https://medium.com/@olgakozlova/%D1%81%D0%B5%D1%82%D0%B8-%D0%B2-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%B0%D1%85-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0%D1%85-http-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB-ajax-jsonp-cors-comet-53c60319a5a7)
  - [Основы TCP/IP для будущих дилетантов](https://habr.com/ru/post/326574/)
  
<br></p></details>

#
<details><summary><b>Чистые функции</b></summary><p>
  
  ---
  
  - Чистая функция:
     - идемпотента 	    - при повторении операции даст тот же эффект
     - детерминирована   - для одних и тех же данных всегда выдаёт тот же результат
     - иммутабельна      - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.
     - без сайд-эффектов - побочных эффектов 
       Например: какой-то внешний объект изменился, и при тех же входящих данных мы получили новый результат
  
      Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.

    
    Пример чистой функции -  не меняет свои входные данные и предсказуемо возвращает один и тот же результат для одинаковых аргументов:
    ```
      function sum(a, b) {
        return a + b;
      }
    ```    
      
    Пример нечистой функции — записывает данные в свои же аргументы:
    ```
    function withdraw(account, amount) {
        account.total -= amount;
      }
    ```
    
  <details>
    <summary>Инкапсуляция = сокрытие лишних деталей</summary>
  </details>
  
  <details>
    <summary>Интерфейс - то как мы взаимодействуем с чем-то</summary>
        - интерфейс объекта - какие свойства и методы у него есть
        - интерфейс функции - её имя, какие параметры мы в неё передаём, какой ответ получаем...
  </details>
  
  <details>
    <summary>Идемпотентность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.</summary>
  </details>
  
  <details>
    <summary>Детерминированность - для одних и тех же исходных алгоритм выдаёт тот же результат.</summary>
      Результат однозначно определяется исходными данными.
  </details>
  
  <details>
    <summary>Иммутабельность - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.</summary>
  </details>

<br></p></details>

#
<details><summary><b>ООП</b></summary><p>
  
  ---
  
**Объе́ктно-ориенти́рованное программи́рование (ООП)** — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

**Базовые понятия**
- **Класс** - абстрактное описание автомобиля. Чертёж
- **Объект** - конкретная реализация автомобиля, данная машина
- **Свойства** - характеристики харакерные для всех машин. Количество колес, цвет, количество бензина... 
- **Методы** - команды, на которые может реагировать машина.	По сути функции, которые может вызывать каждый объект. 
- **Геттеры и сеттеры** - спец. методы, для добавления/получения свойств объекта (чтоб не использовать приватные свойста)

**Базовые принципы ООП**
- **Наследование** — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом. Нужно, прежде всего, для повторного использование кода. Cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
- **Абстракция** - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных.
- **Инкапсуляция** - ограничение доступа к данным и возможностям их изменения. Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.
- **Полиморфизм** — возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат. Cвойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

**Разыне модели (подходы) ООП**
- Компонентно-ориентированное программирование
- Прототипно-ориентированное программирование
- Агентно-ориентированное программирование

**Другие методологии программирования**
- **императивное** - вычисления описываются в виде инструкций, шаг за шагом изменяющих состояние программы.
- **декларативное** - описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между этими состояниями.
- **структурное** - декомпозиция. По-прежнему оперируем состоянием и инструкциями, однако вводится понятие составной инструкции (блока), инструкций ветвления и цикла.
- **процедурное** - исходная задача разбивается на меньшие (с помощью процедур) и это происходит до тех пор, пока решение всех конкретных процедур не окажется тривиальным.
- **модульное** - разделение функциональности на законченные блоки. Программа описанная в стиле модульного программирования — это набор модулей. Что внутри, классы, императивный код или чистые функции — не важно. Благодаря модулям впервые в программировании появилась серьезная инкапсуляция — возможно использовать какие-либо сущности внутри модуля, но не показывать их внешнему миру.
- **функциональное** - всё есть чистая функция, даже числа. Важно "отсутсвие состояния"
- **обощённое** - разделеие на шаблоны
- **реактивное** - ориентированное на потоки данных и распространение изменений. Должна существовать возможность легко выражать статические и динамические потоки данных, а также нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.
- всякие экзотические - автоматное, аппликативное, аспект/агент/компонент-ориентированное...<br> 
Немного подробнее: [«Забытые» парадигмы программирования](https://habr.com/ru/post/223253/)
...

**Шаблоны проектирования "банды четрыёх" GoF**
- [Шпаргалка по шаблонам проектирования](https://habr.com/ru/post/210288/)


**Принципы SOLID**
  <details>
    <summary>S: Single Responsibility Principle (<b>Принцип единственной ответственности</b>)</summary>
      Каждый класс должен решать лишь одну задачу.
  </details>
  
  <details>
    <summary>O: Open-Closed Principle (<b>Принцип открытости-закрытости</b>).</summary>
      Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.
  </details>
  
  <details>
    <summary>L: Liskov Substitution Principle (<b>Принцип подстановки Барбары Лисков</b>).</summary>
      Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
      Классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.
  </details>
  
  <details>
    <summary>I: Interface Segregation Principle (<b>Принцип разделения интерфейса</b>).</summary>
      Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. 
      Клиенты не должны зависеть от интерфейсов, которые они не используют.
  </details>
  
  <details>
    <summary>D: Dependency Inversion Principle (<b>Принцип инверсии зависимостей</b>).</summary>
        Объектом зависимости должна быть абстракция, а не что-то конкретное.
        Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
        Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
  </details>
  
**Другие принципы Объектно Ориентированнаого Дизайна** 
- **Закон Деметры** (англ. Law of Demeter, LoD) - каждый программный модуль:
    - должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.
    - должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
    - обращаться только к непосредственным «друзьям».
    **Ссылки**
    - [habr](https://habr.com/ru/post/319652/)
    - [wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
- **GRASP** (general responsibility assignment software patterns) — общие шаблоны распределения ответственностей 
  - Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения. Постоянно используешь в объекте какой-то внешний метод? Скорее всего, этот метод должен быть в этом объекте
  - высокое сцепление - код выполняющий одну задачу, должне быть в одном месте
  - низкая связность - модули не должны зависеть друг от друга (если они ссылаются друг на друга - это то же самое что у вас один большой модуль)
  - ... (всего 9 принципов)
  - [Wikipedia](https://ru.wikipedia.org/wiki/GRASP)
- **CQS** (Command Query Separation)
  - метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно. 
  - Другими словами, задавание вопроса не должно менять ответ. 
  - Более формально, возвращать значение можно только чистым, не имеющим побочных эффектов методам. Следует отметить, что строгое соблюдение этого принципа делает невозможным отслеживание количества вызовов запросов. 
  - Другими словами: если я спрашиваю у объекта "Ты админ?", он должен вернуть только tru или false. И не должен внутри заниматься изменением состояния
  - [Wikipediz](https://ru.wikipedia.org/wiki/CQRS)
- **Single level of Abstraction** (один уровень абстракции)
  - Каждый метод должен быть написан на одном уровне абстракции.
  - [Single level of abstraction (en)](https://medium.com/@yukas/single-level-of-abstraction-1e2bb6a645d7)

См видео "[Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)"
  
Ссылки:
- [code.mu - на пальцах](http://code.mu/books/javascript/oop/)
- [code.mu - тоже на пальцах](http://code.mu/books/php/oop/osnovy-raboty-s-objektno-orientirovannym-programmirovaniem-v-php-1.html)
- [habr - на пальцах 1](https://habr.com/ru/post/87205/)
- [habr - на пальцах 2](https://habr.com/ru/post/87119/)
- [Что такое ООП в паре слов](https://javarush.ru/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija)
- [habr - Понимание ООП в JS](https://habr.com/ru/company/enterra/blog/153365/)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Details_of_the_Object_Model)  
- [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)  
- [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)
  
<br></p></details>

#
<details><summary><b>MVC</b></summary><p>

<br></p></details>


#
<details><summary><b>Разное</b></summary><p>
  
  ---
  
  **Про что ещё спрашивали:**
  - лексическое всплытие
  - алгоритмическая сложность
  - теория нормализации данных
  - работа DOM браузера: "дорогие" опреации. Relayout / repaint
  - работа DOM браузера: "дорогие" опреации чтения (get.computer.style и т.д.)
  - отслеживание изменений в фреймворке — центральный вопрос для современных фреймворков. Как фреймворк понимает, что что-то изменилось и необходимо применить новые изменения к DOM.
  - работа JS-движка
  - асинхронность и однопоточность JS- понимать, что это значит и чем обусловлено. 
  - как JS распределяет память, как парсится и выполняется код. 
  - мало простого заучивания методов жизненного цикла компонента React — разберитесь, с какой целью они были добавлены.
  
  **Задачки**
  - замыкания
  - Promise & setTimeout - что раньше выполнится
  - куча разных console.log - в каком порядке будут выводиться
  - предложить разные методы организации кэша для вычисления Фибоначчи (кэш ограничен 20 значениями, а поступить может хоть 10000 - как оптимизировать? часть кэша выделяем под хранение предыдущиз вычисленных значений. Рекурсия - самый дорогой вариант)
  - //ToDo - дополнить
  
  **Повторять**
 - Повторить JS eventloop
 - Вспоминать JS - замыкания и т.д.
 - Повторять основные понятия React.
 - Повторять устройство Redux (store, createStore, state, reducer, actions, action creators, dispatch, provider, connect, middleware,  mapDispatchToProps, mapStateToProps)

**Принципы программировани**
 - DRY
 - KISS
 - YAGNI
 +
 - SOLID (см ООП) 
 - GRASP
 - CQS
 - Law of Demeter  (см ООП)
 - Single level of Abstraction Principle
 +
 - Интересные идеи на тему: [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)

<br></p></details>

<br>
<br>

*[Legmo, 2019](https://github.com/Legmo/notes/)*