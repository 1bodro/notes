# Шпаргалка по общим вопросам программирования и frontend-разработки #

#
<details><summary><b>Чистые функции</b></summary><p>
  
  ---
  
  - Чистая функция:
     - идемпотента 	    - при повторении операции даст тот же эффект
     - детерминирована   - для одних и тех же данных всегда выдаёт тот же результат
     - иммутабельна      - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.
     - без сайд-эффектов - побочных эффектов 
       Например: какой-то внешний объект изменился, и при тех же входящих данных мы получили новый результат
  
      Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.

    
    Пример чистой функции -  не меняет свои входные данные и предсказуемо возвращает один и тот же результат для одинаковых аргументов:
    ```
      function sum(a, b) {
        return a + b;
      }
    ```    
      
    Пример нечистой функции — записывает данные в свои же аргументы:
    ```
    function withdraw(account, amount) {
        account.total -= amount;
      }
    ```
    
  <details>
    <summary>Инкапсуляция = сокрытие лишних деталей</summary>
  </details>
  
  <details>
    <summary>Интерфейс - то как мы взаимодействуем с чем-то</summary>
        - интерфейс объекта - какие свойства и методы у него есть
        - интерфейс функции - её имя, какие параметры мы в неё передаём, какой ответ получаем...
  </details>
  
  <details>
    <summary>Идемпотентность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.</summary>
  </details>
  
  <details>
    <summary>Детерминированность - для одних и тех же исходных алгоритм выдаёт тот же результат.</summary>
      Результат однозначно определяется исходными данными.
  </details>
  
  <details>
    <summary>Иммутабельность - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.</summary>
  </details>

<br></p></details>


#
<details><summary><b>ООП - некоторые понятия</b></summary><p>
  
  ---
  
**Объе́ктно-ориенти́рованное программи́рование (ООП)** — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

**Базовые понятия**
- **Класс** - абстрактное описание автомобиля. Чертёж
- **Объект** - конкретная реализация автомобиля, данная машина
- **Свойства** - характеристики харакерные для всех машин. Количество колес, цвет, количество бензина... 
- **Методы** - команды, на которые может реагировать машина.	По сути функции, которые может вызывать каждый объект. 
- **Геттеры и сеттеры** - спец. методы, для добавления/получения свойств объекта (чтоб не использовать приватные свойста)

**Базовые принципы ООП**
- **Наследование** — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом. Нужно, прежде всего, для повторного использование кода. Cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
- **Абстракция** - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных.
- **Инкапсуляция** - ограничение доступа к данным и возможностям их изменения. Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.
- **Полиморфизм** — возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат. Cвойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

**Разные модели (подходы) ООП**
- Компонентно-ориентированное программирование
- Прототипно-ориентированное программирование
- Агентно-ориентированное программирование

**Шаблоны проектирования "банды четрыёх" GoF**
- [Шпаргалка по шаблонам проектирования](https://habr.com/ru/post/210288/)


**Принципы SOLID**
  <details>
    <summary>S: Single Responsibility Principle (<b>Принцип единственной ответственности</b>)</summary>
      Каждый класс должен решать лишь одну задачу.
  </details>
  
  <details>
    <summary>O: Open-Closed Principle (<b>Принцип открытости-закрытости</b>).</summary>
      Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.
  </details>
  
  <details>
    <summary>L: Liskov Substitution Principle (<b>Принцип подстановки Барбары Лисков</b>).</summary>
      Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
      Классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.
  </details>
  
  <details>
    <summary>I: Interface Segregation Principle (<b>Принцип разделения интерфейса</b>).</summary>
      Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. 
      Клиенты не должны зависеть от интерфейсов, которые они не используют.
  </details>
  
  <details>
    <summary>D: Dependency Inversion Principle (<b>Принцип инверсии зависимостей</b>).</summary>
        Объектом зависимости должна быть абстракция, а не что-то конкретное.
        Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
        Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
  </details>
  
  
**Ссылки**
- [code.mu - на пальцах](http://code.mu/books/javascript/oop/)
- [code.mu - тоже на пальцах](http://code.mu/books/php/oop/osnovy-raboty-s-objektno-orientirovannym-programmirovaniem-v-php-1.html)
- [habr - на пальцах 1](https://habr.com/ru/post/87205/)
- [habr - на пальцах 2](https://habr.com/ru/post/87119/)
- [Что такое ООП в паре слов](https://javarush.ru/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija)
- [habr - Понимание ООП в JS](https://habr.com/ru/company/enterra/blog/153365/)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Details_of_the_Object_Model)  
- [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)  
- [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)
  
<br></p></details>


#
<details><summary><b>Другие методологии программирования</b></summary><p>

  - **императивное** - вычисления описываются в виде инструкций, шаг за шагом изменяющих состояние программы.
  - **декларативное** - описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между этими состояниями.
  - **структурное** - декомпозиция. По-прежнему оперируем состоянием и инструкциями, однако вводится понятие составной инструкции (блока), инструкций ветвления и цикла.
  - **процедурное** - исходная задача разбивается на меньшие (с помощью процедур) и это происходит до тех пор, пока решение всех конкретных процедур не окажется тривиальным.
  - **модульное** - разделение функциональности на законченные блоки. Программа описанная в стиле модульного программирования — это набор модулей. Что внутри, классы, императивный код или чистые функции — не важно. Благодаря модулям впервые в программировании появилась серьезная инкапсуляция — возможно использовать какие-либо сущности внутри модуля, но не показывать их внешнему миру.
  - **функциональное** - всё есть чистая функция, даже числа. Важно "отсутсвие состояния"
  - **обощённое** - разделеие на шаблоны
  - **реактивное** - ориентированное на потоки данных и распространение изменений. Должна существовать возможность легко выражать статические и динамические потоки данных, а также нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.
  - всякие экзотические - автоматное, аппликативное, аспект/агент/компонент-ориентированное...<br> 
  Немного подробнее: [«Забытые» парадигмы программирования](https://habr.com/ru/post/223253/)
  ...

  **Ссылки**
  - [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)  

<br></p></details>


#
<details><summary><b>MVC для web</b></summary><p>

Model-View-Controller (модель-вид-контроллер)<br>
Конструкционный шаблон (архитектурный паттерн), описывает способ построения структуры приложения, сферы ответственности и взаимодействие каждой из частей в этой структуре.

Основаня идея: нужно чётко разделять ответственность за различное функционирование в наших приложениях. Делим приложение на три основных компонента, каждый из которых отвечает за различные задачи. 
- **Model** - обработка данных и логика приложения
- **View** - представление данных пользователю (в любом формате)
- **Controller** - обработка действий пользователя, вызов соответствующих рессурсов

Концепция описана в 1979 году. Стала популярна благодаря включению в две среды разработки: Struts и Ruby on Rails. 

Предполагает разделение данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента таким образом, что модификация каждого компонента может осуществляться независимо.

**Model**
Модель служит для извлечения и манипуляций данными приложения. Это данные и правила, которые используются для работы с данными. Модель содержит логику управления данными.

Только данные, которые должны быть обработаны в соответствии с правилами (дата не может указывать в будущее, e-mail должен быть в определённом формате, имя не может быть длиннее Х символов, и так далее).

Модель даёт контроллеру представление данных, которые запросил пользователь (сообщение, страницу книги, фотоальбом, и тому подобное). Модель данных будет одинаковой, вне зависимости от того, как мы хотим представлять их пользователю.

**View**
Представление (Вид) отвечает за видимое пользователю отображение этих данных (то есть, в применении к вебу, формирует отдаваемый сервером браузеру пользователя HTML/CSS). 

Обеспечивает различные способы представления данных, которые получены из модели. Он может быть шаблоном, который заполняется данными. Может быть несколько различных видов, и контроллер выбирает, какой подходит наилучшим образом для текущей ситуации.

**Controller**
Контроллер управляет всем этим оркестром. Содержит организационную логику.

Контроллер может быть устроен как основной, который получает все запросы и вызывает другие контроллеры для выполнения действий в зависимости от ситуации.

**Стандартная схема работы:** 
- Контроллер получает запрос
- Посылает команду Модели на работу с данными
- В заивисмости от ответа Модели Контроллер решает -какое из Представлений вызвать для формирования итогового ответа на изначальный Запрос
- Представление по комнаде Контроллера менет отображение информации на экране.
- Пользователь взаимодействует с Представлением (кликает по кнопке, например), и тем самым формирует новый запрос к Контроллеру

Веб приложение обычно состоит из набора контроллеров, моделей и видов. 
0
**Модификации**<br>
Есть много модификаций швблона MVC -HMVC (Hierarchical MVC) и другие

//ToDo - дополнить

**Ссылки**
- [Концепция MVC для чайников](https://ruseller.com/lessons.php?id=666)
- [MVC для веб: проще некуда](https://habr.com/ru/post/181772/)

<br></p></details>


#
<details><summary><b>Некоторые принципы программирования</b></summary><p>

 - DRY
 - KISS
 - YAGNI
 - SOLID (см ООП) 
 - GRASP
 - CQS
 - Law of Demeter  (см ООП)
 - Single level of Abstraction Principle
 - Интересные идеи на тему: [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)
  
  
  **Некоторые принципы Объектно Ориентированнаого Дизайна** 
  - **Закон Деметры** (англ. Law of Demeter, LoD) - каждый программный модуль:
      - должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.
      - должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
      - обращаться только к непосредственным «друзьям».
      **Ссылки**
      - [habr](https://habr.com/ru/post/319652/)
      - [wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
  - **GRASP** (general responsibility assignment software patterns) — общие шаблоны распределения ответственностей 
    - Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения. Постоянно используешь в объекте какой-то внешний метод? Скорее всего, этот метод должен быть в этом объекте
    - высокое сцепление - код выполняющий одну задачу, должне быть в одном месте
    - низкая связность - модули не должны зависеть друг от друга (если они ссылаются друг на друга - это то же самое что у вас один большой модуль)
    - ... (всего 9 принципов)
    - [Wikipedia](https://ru.wikipedia.org/wiki/GRASP)
  - **CQS** (Command Query Separation)
    - метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно. 
    - Другими словами, задавание вопроса не должно менять ответ. 
    - Более формально, возвращать значение можно только чистым, не имеющим побочных эффектов методам. Следует отметить, что строгое соблюдение этого принципа делает невозможным отслеживание количества вызовов запросов. 
    - Другими словами: если я спрашиваю у объекта "Ты админ?", он должен вернуть только tru или false. И не должен внутри заниматься изменением состояния
    - [Wikipediz](https://ru.wikipedia.org/wiki/CQRS)
  - **Single level of Abstraction** (один уровень абстракции)
    - Каждый метод должен быть написан на одном уровне абстракции.
    - [Single level of abstraction (en)](https://medium.com/@yukas/single-level-of-abstraction-1e2bb6a645d7)
  
  См видео "[Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)"

<br></p></details>

<br>
<br>

*[Legmo, 2019](https://github.com/Legmo/notes/)*