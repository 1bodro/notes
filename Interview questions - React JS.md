# Шпаргалка для интервью React JS frontend #
  
#  
<details><summary><b>JS</b></summary><p>
  
  ---  
  <details><summary><b>Замыкания</b></summary><p>
    
  * v1 - Функция, содержащая в себе ссылки на переменные из внешней области видимости..
  * v2 - Функция вместе со всеми внешними переменными, которые ей доступны.
  * v3 - Функция, получающая переменные из родительской области видимости.
  * v4 - Способность функции запоминать контекст(т.е. LexicalEnvironment), в которой она была создана.
    
  У каждой функции есть область видимости. С внутренней функции мы можем доставать переменные с внешней функции. И еще менять.<br> 
  Это называют "брать из замыкания".<br>
  Вроде бы, в функциональном программировании такой подход не приветствуется. Но знатьу и уметь надо, а в JS - обязательно.
   
  Например, функция запоминила значение "a" из области своего создания. Её вызывают уже вне этой области, а она возвращает это "а.<br> 
  Т.е. она "замыкает" внешние переменные в себе.
  
  Вот ты вызвал функцию, в ней создаются переменные локальной области видимости, т.е. доступные только самой функции.<br>
  Под эти переменные движок JavaScript выделяет память.
  
  Когда обычная функция завершает свое выполнение - она освобождает память, которую выделял раньше, если на переменные не осталось ссылок.
  
  В случае с замыканием, ты возвращаешь функцию обратно, т.е. ссылки остаются, поэтому движок не может освободить память, и переменные остаются доступными функции, и более никому. Поэтому эта штука и называется замыкание, т.к. переменные замкнуты на саму функцию.
  
  Другими словами, чтобы создать замыкание, ты должен вложить функцию в функцию, обратиться из вложенной функции к переменным оборачивающей, и вложенную функцию вернуть наружу. До тех пор, пока возвращенная функция остается в доступе, замыкание существует.
  
  Один из основных паттернов, для которых применяются замыкания - ограничение доступа к данным, их изоляция (ограничение их области видимости).
  
  В то же время замыкание выступает в роли автономного атомарного хранилища данных, и, по идее, должно обеспечивать доступ к этим данным, тем или иным способом.
      
  <b>«Понимать замыкания»</b> в JavaScript означает понимать следующие вещи:
  * Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
  * При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
  * При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».
  
  ```
    function sayHi(name) {
      var phrase = "Привет, " + name;
      alert( phrase );
    }
    
    sayHi('Вася');
  ```    
  
  **Ссылки:**
  * [learn.javascript.ru](https://learn.javascript.ru/closures)
        
  <br></p></details>
  

  <details><summary><b>Стрелочные функции</b></summary><p>
    
  Не имеют своего this. Внутри стрелочных функций тот же this, что и снаружи. Удобно в обработчиках событий и коллбэках.<br>
  Не имеют своего arguments. Используются аргументы внешней «обычной» функции.<br>
  Появились в ES6.
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/es-function)
        
  <br></p></details>
         
         
  <a name="js_callback"></a>
  <details><summary><b>Callback</b></summary><p>
    
  Функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback – функция обратного вызова).
   
  Сами не вызываем функцию. Отдаём её как аругмент в другую функции, и та вызывает, когда сочтёт нужным.
   
  Чуть сложнее: В JavaScript функции – это объекты. Поэтому функции могут принимать другие функции в качестве аргументов, а также функции могут возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего порядка. А любая функция, которая передается как аргумент, называется callback-функцией.
    
  Пример: 
    ``<button onClik={function}>txt</button>``<br> 
  Когда произойдёт событие onClick, кнопка вызовет эту функцию.
  Нет скобок после function - мы не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо. От своего имени
  
  Неправильно: 
    ``<button onClik={function()}>txt</button>``<br> 
  Здесь функция не передаётся, а сразу вызывается.
      
  <b>Зачем?</b>
  JS - событийно-ориентированный язык. Если функция не отвечает немедленно (например выполянет AJAX-запрос или Timeout) - JS не будет останавливать работу, ожидая ответа. Он продолжит выполнение других функций, одновременно ожидая ответа от нашей функции. Вывод: нельзя просто вызывать функции в нужном порядке и надеяться, что они в обязательно выполнятся в том же порядке.<br>
  
  Пример: 
  ```
    function first(){
      // Как будто бы запрос к API
      setTimeout( function(){
        console.log(1);
      }, 500 );
    }
    function second(){
      console.log(2);
    }
    first();
    second();
    
    //Выдаст ответ:
    // 2
    // 1
  ```
  Коллбэки позволяют нам быть уверенными в том, что определенный код не начнет исполнение до того момента, пока другой код не завершит исполнение.     
      
  При вызове callback может нарушиться контекст вызова this. Т.е. отвалиться привязка this к родительскому объекту.
  ```
  <App
      addQuote={store.addQuote}
    />
  ```
  
  В таком случае, при создании callback надо сделать привязку контекста - bind
  ```
    <App
      addQuote={store.addQuote.bind(store)} 
    />
  ```
  
  Функции call() и apply() - ещё один способ вызова callback-функции. Здесь мы сами устанавливаем контекст, в котором выполняется функция. Это означает, что когда мы используем ключевое слово this внутри нашей callback-функции, оно ссылается на то, что мы передаём первым аргументом в call()/apply. (см. ниже)
  
  Пример:
  ```
  function showFullName() {alert(что-нибудь)}
  
  var user = {что-то}
  
  function_name.call(user); // вызываем колбек и в качестве контекста this передаём ему user

  ```
  
  Ссылки:
  * [habr - Понимание callback-функций (колбеков)](https://habr.com/ru/post/151716/)
  * [hexlet](https://ru.hexlet.io/blog/posts/javascript-what-the-heck-is-a-callback)
  
  <br></p></details>


  <a name="js_cal-aply"></a>
  <details><summary><b>"Call" & "apply"</b> //ToDo - доработать</summary><p>
  
  Явное указание this
  
  Мы сами устанавливаем контекст, в котором выполняется функция. Это означает, что когда мы используем ключевое слово this внутри нашей callback-функции, оно ссылается на то, что мы передаём первым аргументом в call()/apply
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/call-apply)
  * [habr](https://habr.com/ru/post/199456/) 
  
  <br></p></details>   


  <a name="js_bind"></a>
  <details><summary><b>Bind</b></summary><p> 
    
  Метод. Позволяет привязать контекст к функции. Важно при callback
  
  Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
    
  При вызове callback может нарушиться контекст вызова this. Т.е. отвалиться привязка this  к родительскому объекту.
  ```
      <App
        addQuote={store.addQuote} //нет скобок после addQuote
      />
  ```
  Не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо, от своего имени.
  
  В таком случае, при создании callback надо сделать привязку контекста - bind
  ```    
      <App
        addQuote={store.addQuote.bind(store)} 
      />
  ```
  
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/bind)
  * [code.mu](http://code.mu/javascript/context/bind.html) 
  * [habr](https://habr.com/ru/post/199456/) 
  * [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
  <br></p></details>
    
  <a name="js_events-handlers"></a>
  <details><summary><b>Обработчики событий</b> (events handlers)</summary><p>
    
  Блоки кода (обычно функции), которые позволяют обрабатывать события (щелчок мыши...) и реагировать на них.
  
  Когда такой блок кода определяют для запуска в ответ на некое событие, говорят "мы регистрируем обработчик событий". 
  Иногда обработчики называют прослушивателями событий (event listeners). Термины часто взаимозаменяемы, но вообще: _прослушиватель_ слушает событие, а _обработчик_ — это код, который запускается в ответ на событие.
  
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/introduction-browser-events)
  * [MDN](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F)
  * [professorweb.ru](https://professorweb.ru/my/javascript/js_theory/level2/2_5.php)
      
  <br></p></details>
        
   
  <a name="js_objects-arrays"></a>
  <details><summary><b>Объекты {} и массивы []</b></summary><p>
                                                  
  - ``{ width: 300,  height: 200, }`` - объект. Структура для хранения данных в формате ключ-значение.
  - ``[ 300, 200, ]``                 - массив. Для хранения пронумерованных значений. Особый тип объектов. 
        
 Объект - ассоциативный массив: структура, пригодная для хранения любых данных. В других языках программирования такую структуру данных также называют «словарь» и «хэш». В JS объекты также используются как элементы ООП, это немного отдельно. 
  
 Массивы обычно используются для хранения _упорядоченных_ коллекций данных, например – списка товаров на странице, студентов в группе и т.п. Предлагает дополнительные методы для удобного манипулирования такой коллекцией. Элементы в массиве должны идти подряд, иначе теряется большая часть преимуществ этой структуры.
    
  Ссылки:
  * [learn.javascript.ru - Массивы](https://learn.javascript.ru/array)
  * [learn.javascript.ru - Объекты](https://learn.javascript.ru/object)
      
  <br></p></details>
  
  <details><summary><b>var = х</b></summary><p>
  
  Способ объявления переменной. Используем в обычных случаях
  
  Область видимости переменной var – функция.
  
  var существуют и до объявления. Они равны undefined.
  
  При использовании в цикле у нас будет одна var на все итерации цикла. Не создаётся заново в каждой итерации.
  
  Не надо объявлять переменные без указания директивы (например var или let). 
  ```
  //Т.е. так писать не стоит
  a = 1
  
  //Надо так
  var a = 1
  
  //Или так
  let a = 1
  
  //Или так
  const a = 1
  ```
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/variables)
  * [learn.javascript.ru](https://learn.javascript.ru/let-const)
       
  <br><p></details>
  

  <details><summary><b>let = х</b></summary><p>
    
  Способ объявления переменной. Используем если будем переопределять значение переменной. Видна в блоке
  
  Область видимости переменной let – блок {...}, в котором объявлена.<br>
  Это, в частности, влияет на объявления внутри if, while или for.
  
  let видна только после объявления. До тех пор их просто нет.
  
  При использовании в цикле, для каждой итерации создаётся своя переменная.
  
  Введена в язык в ES6 (ES-2015)
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/variables)
  * [learn.javascript.ru](https://learn.javascript.ru/let-const)
       
  <br><p></details>

  <details><summary><b>const = х</b></summary><p>

  Способ объявления переменной. Используем для констант 

  Объявление const задаёт константу, то есть переменную, которую нельзя менять. При попытке изменения выдаст ошибку.
  
  Eсли в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё.
  
  В остальном - аналогичная let.
  
  Функции обычно лучше создавать через const.
  
  Вообще хороший вариант объявления чего-то, что мы не собираемся менять.
  
  Константы, которые жёстко заданы всегда, во время всей программы, обычно пишутся в верхнем регистре. Например: const ORANGE = "#ffa500".
  
  Большинство переменных – константы в другом смысле: они не меняются после присвоения. Но при разных запусках функции это значение может быть разным. Для таких переменных можно использовать const и обычные строчные буквы в имени.
  
  Введена в язык в ES6 (ES-2015)
    
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/variables)
  * [learn.javascript.ru](https://learn.javascript.ru/let-const)
       
  <br><p></details>
  
  <details><summary><b>Promises</b></summary><p>
    
  Cпособ организации асинхронного кода. Объект, который содержит своё состояние
  
  Способ использования:
    
   1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
   1. Внешний код, получив promise, навешивает на него обработчики.
   1. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
       
  Состояния promises:
  - вначале pending («ожидание»), 
  - затем либо fulfilled («выполнено успешно») 
  - либо rejected («выполнено с ошибкой»).
 
  На promise можно навешивать коллбэки двух типов:
  - onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
  - onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
  
  Обработчики назначаются вызовом `then/catch`
  - .then = универсальный метод для навешивания обработчиков:
      - promise.then(onFulfilled, onRejected) //(удачно, неудачно)
  - .catch = чтобы поставить обработчик только на ошибку
      - вместо .then(null, onRejected) 
      - можно  .catch(onRejected) – это то же самое.
      
  Синхронный throw – то же самое, что reject<br>
  Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:
    ```      
      let prom = new Promise((resolve, reject) => {
        throw new Error("o_O");  // то же что reject(new Error("o_O"))
      })
      pprom.catch(alert); // Error: o_O
    ```
    
  <b>Сhaining (чейнинг)</b>- возможность строить асинхронные цепочки из промисов<br>
  Основная причина, из-за которой существуют и активно используются промисы.
  
  Например, мы хотим по очереди:
  * Загрузить данные посетителя с сервера (асинхронно).
  * Затем отправить запрос о нём на github (асинхронно).
  * Когда это будет готово, вывести его github-аватар на экран (асинхронно).
  * …И сделать код расширяемым, чтобы цепочку можно было легко продолжить.
  ```
    httpGet('/article/promise/user.json') //делаем запрос
    .then(...)
    .then(...)
    .then(...)
  ```
  При чейнинге .then…then…then, в каждый следующий then переходит результат от предыдущего.<br> 
  Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
  
  Ссылки:
  *[learn.javascript.ru](https://learn.javascript.ru/promise)
  * [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  * [habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
  
  <br></p></details>
  
    
  <details><summary><b>Async/Await</b></summary><p>
  
  Асинхронные функции на основе promises
  
  Асинхронные функции позволяют избавиться от так называемого «ада коллбэков» и улучшить внешний вид и читаемость кода.
  
  Работают поверх Promises
  
  Ключевое слово async сообщает JavaScript-интерпретатору о том, что функцию, объявленную с этим ключевым словом, нужно воспринимать по-особому. Систем приостанавливается, достигая ключевого слова await в этой функции. Она считает, что выражение после await возвращает промис и ожидает разрешения или отклонения этого промиса перед продолжением.
  
  В следующем примере функция getAmount() вызывает две асинхронные функции — getUser() и getBankBalance().<br>
  Сделать это можно и в промисе, но использование конструкции async/await позволяет решить эту задачу проще и элегантнее.
  
  Ссылки:
  * [habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
  * [habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
  * [learn.javascript.ru (en)](https://javascript.info/async-await)
  * [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  * [habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
  
  <br></p></details>
  
  
  <details><summary><b>Асинхронность в JS. Event loop</b> //ToDo - доработать</summary><p>
  
   Ну, это про то как устроена работа с асинхронными событиями в JS и браузере. И как они взаимодействуют.<br>
   Стэк вызова, очередь, event loop, web workers... Вот это вот всё...<br>
   Сюда же - микро-задачи и макро-задачи
   
   Почему promise отработают раньше timeout и т.д.<br>
     
  Ссылки:
  * [habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
  * [habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
  * [habr - Знай свой инструмент: Event Loop в libuv](https://habr.com/ru/post/336498/)
  * [learn.javascript.ru (en)](https://javascript.info/async-await)
  * [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
  * [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
  * [Как управлять event loop в JavaScript. Часть 1](https://skillbox.ru/media/code/event_loop_chast_1/)
  * [Как управлять event loop в JavaScript. Часть 2](https://skillbox.ru/media/code/event_loop_chast_2/)
  * [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  * [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
  * [Hexlet](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/event-loop/theory_unit)
  * [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  * [habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
   
  <br></p></details>   
  
  
  <details><summary><b>Как работают современные движки JavaScript?</b> //ToDo - доработать</summary><p>
  
  Прежде всего, исходный код (текст на JS) проходит через парсер, в результате возникает внутреннее представление кода — абстрактное синтаксическое дерево. 
  
  Дальше работает интерпретатор. Отдельные функции при исполнении преобразуются в байт-код — по сути, последовательность вызовов внутренних функций интерпретатора. При этом накапливается статистика использования JS-функций. Если для какой-то отдельной функции преоделён порог вызовов, то принимается решение о том, что её нужно оптимизировать и она передаётся компилятору. Компилятор генерирует машинный код, который сильно завязан на типы входных значений.
  
  ![](https://hsto.org/r/w1560/webt/g-/tv/yx/g-tvyxlxy0e3kc0c_quq_r0d9uo.png)
  
  Допустим, у нас есть функция с двумя аргументами: foo(a, b), и мы вызываем её много раз с числовыми значениями параметров. В некоторый момент функция будет передана компилятору и станет выполняться быстрее. Допустим, мы вызовем её со строковым аргументом. В результате, движок выполнит «деоптимизацию»: передаст функцию от компилятора обратно интерпретатору, а готовый машинный код будет выброшен.
  
  **Ссылки**
  - [habr - Знакомство с WebAssembly](https://m.habr.com/ru/post/342180/)
  
  <br></p></details>   
  
  <details><summary><b>Proxy-объекты</b></summary><p>
    
  Особые объекты, позволяют перехватывать и изменять действия, выполняемые над другими объектами.

  В частности, речь идёт о вызове функций, об операциях присваивания, о работе со свойствами, о создании новых объектов, и так далее.<br>
  Эту технологию используют для блокирования прямого доступа к целевому объекту или целевой функции и организации взаимодействия с объектом или функцией через прокси-объект.
  
  Так выглядит объявление простого прокси-объекта, которому передаётся целевой объект и обработчик:<br>
  `let proxy = new Proxy(target, handler);`
  
  **Стандартное поведение объектов**<br>
  Объявим объект, а затем попробуем обратиться к несуществующему свойству этого объекта.
  ```
    let obj = {
      c: "car",
      b: "bike"
    };

    document.write(obj.b, ""); //Результат -> "bike"
    document.write(obj.c, ""); //Результат -> "car"
    document.write(obj.l); 	   //Результат -> "undefined"
  ```
  
  **Использование прокси для объекта**<br>
  Используем обработчик с перехватчиком get. Обработчик передаст целевой объект и запрошенный ключ перехватчику.
  ```
    let handler = {
        get: function(target, name) {
        return name in target ? target[name] : "Key does not exist";
      }
    }

    let obj = {
      c: "car",
      b: "bike"
    };

    let proxyObj = new Proxy(obj, handler);

    document.write(proxyObj.b, ""); //Результат -> "bike"
    document.write(proxyObj.c, ""); //Результат -> "car"
    document.write(proxyObj.l);     //Результат -> "Key does not exist"
  ```
  
  Ссылки:
  * [habr](https://habr.com/ru/company/ruvds/blog/359060/)
  
  <br></p></details>
  
  <details><summary><b>Функции-генераторы</b> - function* ()</summary><p>
    
  Могут приостанавливать своё выполнение, возвращать промежуточный результат и возобновляться позже.<br>
  Код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют «генератором»
  
  Генератор связан с итераторами. В частности, он является итерируемым объектом.
  
  Один генератор может включать в себя другие. Это называется композицией.
  
  **Плоский асинхронный код**
  
  Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
  
  Общий принцип такой:
  - Генератор yield'ит не просто значения, а промисы.
  - Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами next получает из него промисы – один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим next.
  - Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат – например, возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.

  Появились в ES6.
      
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/generator)
  
  <br></p></details>
  
  
  <details><summary><b>Итераторы</b></summary><p>
  
  Тип объектов, содержимое которых можно перебрать в цикле
    
  По сути - объект, предназначенный для перебора другого объекта.<br>
  Например массив, функция-генератор, список DOM-узлов, строка..
  
  Для перебора таких объектов добавлен новый синтаксис цикла: for..of.
  
  Итераторы дают возможность сделать «перебираемыми» любые объекты.
  
  Ссылки:
  * [learn.javascript.ru](https://learn.javascript.ru/iterator)
    
  <br></p></details>
  
   
  <details><summary><b>function()()</b></summary><p>
    
  Зачем при вызове функции ставят две двойные скобки?
    
  Функция getFunc() возвращает другую функцию (та что в переменной func).<br> 
  Вторые скобки нужны чтобы вызвать функцию, которую вернула getFunc().<br>
  Если скобки опустить, то return внешней функции вернет Вам не результат а саму функцию. 
  
  Пример:
  ```
        var a = 1;
        function getFunc() {
          var a = 2;
          var func = function() { alert(a); };
          return func;
        }
        getFunc()(); // 2, из LexicalEnvironment функции getFunc
  ```

  <br></p></details>
  

  <details><summary><b>WebAssembly</b></summary><p>
  
  WebAssembly (WASM) — бинарный формат, позволяющий запускать код в браузере
  
  Точнее: бинарный формат инструкций для стековой виртуальной машины. WebAssembly спроектирован как портативная цель компиляции для высокоуровневых языков, таких как C/C++/Rust, которую можно развертывать в web для клиентских и серверных приложений.
  
  Представляет собой переносимое абстрактное синтаксическое дерево, обеспечивающее как более быстрый анализ, так и более быстрое выполнение кода, чем JavaScript.
  
  **Зачем?**
  - быстро исполнять код в браузере. Быстрее чем JavaScript — в идеале, со скоростью света родного кода нашего процессора.
  - Zero configuration — решение «из коробки», без установки, нужен только браузер.
  - Безопасно — новая технология не должна создавать новых угроз.
  - Кросс-платформенно — у нас есть несколько платформ, включая мобильные, несколько операционных систем.
  - Удобно для разработчиков — нужны удобные средства разработки и отладки.
  
  В принципе,эту задачу решает JS. Что плохо: нужен плагин и/или runtime ⇒ нет zero configuration. У JS есть внутренние ограничения, которые уже не позволят сделать его радикально быстрее. 
  
  Потенциальные альтернативы (не прижились): 
  - NaCl (Native Client) - Google
  - PNaCl (Portable Native Client) - LLVM IR subset.
  - asm.js - Mozilla
  
  **Преимущества WebAssembly**
  - Скорость — почти как родной код.
  - Эффективность — бинарный формат, быстрый парсинг и компиляция.
  - Портируемость — все браузеры и операционные системы.
  - Безопасность — запуск в sandbox.
  - Удобство отладки — поддержка отладки в браузерах, отладчик есть уже сейчас.
  - Открытый стандарт — то есть это уже не инициатива отдельной компании, пытающейся «перетянуть одеяло на себя». Стандарт уже принят, в 2017 году.

  **Так что же такое WebAssembly?**
  - Бинарный формат
  - НЕ язык программирования, а байт-код. Мы же не называем Java-байткод языком программирования.
  - Загружается в браузер и исполняется в браузере. Формально, WebAssembly исполняется JavaScript-движком, а не самим браузером, поэтому есть и другие варианты исполнения, например, под NodeJS.
  - Исполняется виртуальной машиной. Это простая стековая машина с памятью, простота позволяет легко реализовать её для любого современного процессора.
  - НЕ имеет ничего общего с Web, кроме того что общается с внешним миром через JavaScript. Действительно, WebAssembly это просто виртуальная машина, имеющая память и исполняющая инструкции.

  **Ссылки:**
  - [habr - Знакомство с WebAssembly](https://m.habr.com/ru/post/342180/)
  - [Википедия - WebAssembly](https://ru.wikipedia.org/wiki/WebAssembly)
  
  <br></p></details>
  
  <details><summary><b>Деструктуризация массивов</b></summary><p>

  const [fruit, setFruit] = useState('банан');

  Такой синтаксис в JS называется «деструктуризацией массивов (array destructuring)». 
  Он означает, что мы создаём две новые переменные, fruit и setFruit. 
  Во fruit будет записано первое значение, вернувшееся из useState, а в setFruit — второе. 

  Это равносильно такому коду:
    var fruitStateVariable = useState('банан'); // Возвращает пару значений
    var fruit = fruitStateVariable[0]; // Извлекаем первое значение
    var setFruit = fruitStateVariable[1]; // Извлекаем второе значение

  Когда мы объявляем переменную состояния с помощью функции useState, мы получаем от неё пару, то есть массив из двух элементов. Первый элемент обозначает текущее значение, а второй является функцией, позволяющей менять это значение.
  
  <br></p></details>
  
  <details><summary><b>Утечки памяти в JS</b></summary><p>
    
  1. Глобальные переменные - неявное объявление<br>
    Пример:
    ```  
      function foo(arg) {
        bar = "скрытая глобальная переменная"; // это то же: window.bar = "явно объявленная глобальная переменная";
      }
    ```    
    Решение: добавляйте 'use strict'; в начало JavaScript-файлов
        
  2. Глобальные переменные - явно объявленные, не вычищенные (кэши и т.д.)<br>
  Это касается глобальных переменных, использующихся для временного хранения и обработки больших блоков данных. Если вам нужна глобальная переменная, чтобы записать в неё большое количество информации, убедитесь, что в конце работы с данными её значение будет установлено в null или переопределено. <br>
  Примером увеличенного расхода памяти, связанным с глобальными переменными, являются кэши — объекты, которые сохраняют повторно используемые данные. Для эффективной работы их следует ограничивать по размеру. Если кэш увеличивается без ограничений, он может привести к высокому расходу памяти, поскольку его содержимое не может быть очищено сборщиком мусора.
  
  3. Забытые таймеры и коллбэки<br> 
    Пример:
    ``` 
      var someResource = getData();
      setInterval(function() {
          var node = document.getElementById('Node');
          if(node) {
              // Сделаем что-нибудь с node и someResource.
              node.innerHTML = JSON.stringify(someResource));
          }
      }, 1000);
    ```
  
  4. Забытые обработчики событий<br>
    Обработчики следует удалять, когда они становятся не нужны, или ассоциированные с ними объекты становятся недоступны.<br> 
    В прошлом это было критично, так как некоторые браузеры (Internet Explorer 6) не умели грамотно обрабатывать циклические ссылки.<br> 
    Большинство современных браузеров удаляет обработчики событий, как только объекты становятся недостижимы. <br>
    Однако по-прежнему правилом хорошего тона остаётся явное удаление обработчиков событий перед удалением самого объекта.<br>
    Рекомендуется явно удалять обработчики событий (removeEventListener) до удаления DOM-узлов или обнулять ссылки внутри обработчиков.<br>
  
  5. Ссылки на удалённые из DOM элементы
  
  6. Замыкания - при опр. условиях
  
  Ссылки:
  *[habr](https://habr.com/ru/post/309318/)
  
  <br></p></details>
  
  <details><summary><b>Debounce</b></summary><p>
    
  "Декоратор" который возвращает обертку. Она откладывает вызов исходной функции на определенное время.
  
  Декораторы (микропаттерны оптимизации) функций позволяют добавить дополнительное поведение функции, не изменяя ее. 
    
  Превращает несколько вызовов функции в течение определенного времени в один вызов.<br> 
  Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова. 
  
  Возможны два варианта:
  - Реальный вызов происходит только в случае, если с момента последней попытки прошло время, большее или равное задержке.
  - Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не пройдет время, большее или равное задержке, отсчитанной от времени последней попытки.
  
  **Зачем?**<br>
  Обычно debounce используют, если исходная функция вызывается чаще, чем это требуется.<br>
  Например, DOM-события mousemove, resize, scroll генерируют очень частые вызовы обработчиков, поэтому в ряде случаев было бы полезно обернуть такие обработчики в debounce.<br>
  Другое применение – контроль пользовательского ввода текста: если при изменении поля INPUT требуется передавать на сервер текущее введенное значение, это может создать большое количество однотипных запросов, особенно если пользователь печатает очень быстро. В этом случае тоже весьма кстати будет ограничить число вызовов обработчика с помощью debounce.<br>
  Функция debounce крайне полезна, когда дело доходит до производительности обработчиков событий.
  
  Ссылки:
  * [habr - Декораторы](https://habr.com/ru/post/60957/)
  * [Для чего нужна функция debounce и как она работает](http://gdrw.ru/reviews/tech/debounce-function-in-javascript)
  * [learn.javascript.ru - реализация на js](https://learn.javascript.ru/task/debounce)
  * [7 важных функций JavaScript](https://getinstance.info/articles/javascript/essential-javascript-functions/)
    
  <br></p></details>
  
  
  <details><summary><b>Мемоизация</b></summary><p>
      
  Разновидность кэширования.
  
  Запоминаем предыдущие результаты вызова функции, и если вызывается снова - используем их из кэша
  
  Для того, чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой, всегда возвращать одни и те же значения в ответ на одни и те же аргументы.
 
 Мемоизация — это компромисс между производительностью и потреблением памяти. Мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти.
 
 Может показаться, что собственные реализации мемоизации стоит применять, например, при обращениях к неким API из браузерного кода. Однако, делать этого не нужно, так как браузер автоматически кэширует их, используя, в частности, HTTP-кэш.
 
 Если вы работаете с React/Redux, можете взглянуть на reselect. Тут используется селектор с мемоизацией. Это позволяет выполнять вычисления только в том случае, если в соответствующей части дерева состояний произошли изменения.
 
 Пожалуй, лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, ресурсоёмкие вычисления. Здесь данная техника может значительно повысить производительность решения. Надо отметить, что нечто вроде вычисления факториала или чисел Фибоначчи — это хорошие учебные примеры, но в реальном мире всё гораздо интереснее и сложнее.
  
  Ссылки:
  [https://habr.com/ru/company/ruvds/blog/332384/](https://habr.com/ru/company/ruvds/blog/332384/)
  
  <br></p></details>  
<br></p></details>

#
<details><summary><b>JS - приёмы</b></summary><p>
                                         
  ---
  <details><summary><b>_переменная</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной начинается с _ , её не надо менять или читать снаружи объекта.<br>
  Это просто соглашение об именовании, которое напоминает разработчику о том, что переменная (свойство) или метод являются либо private, либо protected, и к ним нельзя получить доступ из-за пределов класса. 
  
  Чтоб делать это - используй специальные методы: 
  * сеттеры (set... - присвоить) 
  * геттеры (get... - получить)
  
  **Ссылки**
  * [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69) 

  <br><p></details>
  
  <details><summary><b>ПЕРЕМЕННАЯ</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной написано ЗАГЛАВНЫМИ, её не надо менять. Это константа.<br>
  
  **Ссылки**   
  * [learn.js](https://learn.javascript.ru/variables)      
  * [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)
   
  <br><p></details>
  
  <details><summary><b>Переменная</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной начинается с заглавной, значит это не переменная а класс ООП.<br>
  У класса есть методы и всё такое...
     
  **Ссылки**
  * [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69) 
  
  <br><p></details>
              
  <details><summary><b>true && expression</b></summary><p>
    
  `true && expression</b>` - всегда вычисляется как expression, 
    
  `false && expression` - всегда вычисляется как false.
    
  <br></p></details>
  
  <details>
    <summary><b>Math.ceil(x)</b> - метод, округляет x в большую сторону</summary><p>
    
  **Ссылки:**
  - [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)
  
  <br></p></details>
<br></p></details>

#
<details><summary><b>JS - история версий</b></summary><p>

  ---
  <details><summary><b>История версий ES</b></summary><p>
    
  JavaScript создавался как скриптовый язык для Netscape. Изначально разработкой занимались Брендан Эйх, Марк Андрессен и Билл Джой.<br>
  После чего он был отправлен в ECMA International для стандартизации (ECMA — это ассоциация, деятельность которой посвящена стандартизации информационных и коммуникационных технологий). Стандартизированная версия имеет название ECMAScript, описывается стандартом ECMA-262.
  
  ECMAScript — стандарт, а JavaScript — самая популярная реализация этого стандарта.</br>
  Среди других реализаций можно отметить SpiderMonkey, V8 и ActionScript.
      
  ECMAScript - стандарт, развивается и поддерживается ассоциацией [ECMA International](http://www.ecma-international.org/memento/index.html). Ecma International Technical Committee 39 (он же TC39) — комитет очень умных людей :) Задача TC39 - поддержка и обновление спецификации ECMAScript, после обсуждения и всеобщего согласия. Сюда относятся синтаксис языка, семантика, библиотеки и сопутствующие технологии, на которых основывается язык. 
  
  С 2015 года принято решение обновлять язык ежегодно.<br>
  ES.Next - термин является динамическим и автоматически ссылается на новую версию ECMAScript. 
      
  * ES1 - 1997
  * ES2 - 1998
  * ES3 - 1999
  * ES4 - не выпущена
  * ES5 - 2009
  * ES6 - 2015
  * ES7 - 2016
  * ES8 - 2017
  * ES9 - 2018
      
  **Ссылки**
  * [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
  * [Официальная спецификация - актуальная (en)](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
  * [Официальная спецификация - архив (en)](https://www.ecma-international.org/publications/standards/Ecma-262-arch.htm)
  * [Разъяснения насчёт JavaScript, ECMA–262, TC39 и транскомпиляторов ECMAScript](https://www.frontender.info/javascript-ecma-262-tc39-and-ecmascript-transpilers-explained/)
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

  <br></p></details>
  
  <details><summary><b>ES9 (ECMAScript 2018 )</b></summary><p>
    
  * <b>Разделяемая память (shared memory) и атомарные операции (atomics)</b> - касается ядра JS-движков. Позволяет писать высокопроизводительные параллельные приложения, дает возможность управлять памятью самостоятельно, не отдавая выполнение всех аспектов этой задачи JS-движку.
  * <b>Оператора rest</b> - выглядит как три точки. Позволяет извлекать свойства объекта. Используется в левой части выражения.
  * <b>Оператор spread</b> - тоже выглядит как три точки. Используется для создания новых объектов. Используется в правой части выражения со знаком присваивания.
  * <b>Асинхронная итерация, цикл for-await-of</b> - позволяет создавать циклы, работающие с асинхронным кодом. Добавляется новый оператор цикла вида <b>for-await-of</b>, который позволяет вызывать асинхронные функции, возвращающие промисы (или обрабатывать массивы, содержащие промисы) в цикле.
  * <b>Метод finally()</b> — это новый метод объектов Promise. Позволяет выполнять функцию обратного вызова после resolve() или reject(), чтобы корректно завершать операции (например, высвобождая ресурсы).
   * <b>Устранение ограничений тегированных шаблонных строк</b> - больше свободы, что писать в шаблонных строках.
  * <b>Регулярки. Флаг dotAll</b> - изменили настройки регулярок. Чтоб работать в новом формате - устанавливаем спец. флаг.
  * <b>Регулярки. Захват именованных групп</b> - позволяет писать регулярные выражения с назначением имён (идентификаторов) для групп. Облегчает работу с группами.
  * <b>Регулярки. Ретроспективная проверка</b> - позволяет узнать, существует ли некая строка сразу перед некоторой другой строкой.
  * <b>Регулярки. Улучшена поддержка Unicode</b> - можно использовать спец. конструкцию для поиска символов не-латинских языков(хинди, греческий...)
  
  **Ссылки**
  * [Официальная спецификация (en)](http://www.ecma-international.org/publications/standards/Ecma-262.htm)
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)
  * [Что нового в ES2018 JavaScript](https://webformyself.com/chto-novogo-v-es2018-javascript/)

  <br></p></details>

  <details><summary><b>ES8 (ECMAScript 2017)</b></summary><p>
  
  * <b>Конструкция Async/Await</b> - асинхронные функции, работают на основе promise 
  * <b>Метод Object.values()</b> - возвращает все значения собственных свойств объекта, исключая любые значения в цепочке прототипов.
  * <b>Меотд Object.entries()</b> - похож на метод Object.keys(), но вместо того, чтобы возвращать лишь ключи, он возвращает, в виде массива, и ключи, и значения. Упрощает выполнение операций c объектами в циклах, или преобразование обычных объектов в объекты типа Map.
  * <b>Методы дополнения строк до заданной длины</b> - String.prototype.padStart() и String.prototype.padEnd().
  * <b>Метод Object.getOwnPropertyDescriptors()</b> -  возвращает все сведения (включая данные о геттерах и сеттерах) для всех свойств заданного объекта. Позволяет создавать мелкие копии объектов и клонировать объекты, создавая новые объекты, при этом копируя, помимо прочего, геттеры и сеттеры. 
  * Теперь можно ставить <b>завершающие запятые</b> после последнего параметра функции
    
  **Ссылки**
  * [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/8.0/index.html)      
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)  

  <br></p></details>
  
  <details><summary><b>ES7 (ECMAScript 2016)</b></summary><p>
      
  * <b>Метод Array.prototype.includes()</b> - метод объектов типа Array, который позволяет выяснить, имеется ли в массиве некий элемен. <br>
  * <b>Оператор возведения в степень</b> - **. Заменяет Math.pow().
      
  **Ссылки**
  * [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/7.0/index.html)     
  * [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

  <br></p></details>
  
  <details><summary><b>ES6 (ECMAScript 2015)</b></summary><p>
      
  * [Переменные: let и const](https://learn.javascript.ru/let-const)
  * [Деструктуризация](https://learn.javascript.ru/destructuring)
  * [Функции](https://learn.javascript.ru/es-function)
  * [Строки](https://learn.javascript.ru/es-string) - введены шаблоны, улучшена поддержка Unicode, добавлены методы
  * [Объекты и прототипы](https://learn.javascript.ru/es-object)
  * [Классы](https://learn.javascript.ru/es-class)
  * [Тип данных Symbol](https://learn.javascript.ru/symbol) - для создания уникальных идентификаторов
  * [Итераторы](https://learn.javascript.ru/iterator) - можно сделать "перебираемым любой" объект
  * [Set, Map, WeakSet и WeakMap](https://learn.javascript.ru/set-map) - новые типы коллекций
  * [Promise](https://learn.javascript.ru/promise) - способ организации асинхронного кода/p>
  * [Генераторы](https://learn.javascript.ru/generator) - новый вид функций. Могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять выполнение позже.
  * [Модули](https://learn.javascript.ru/modules) - введён официальный стандрат поддержки модулей в JS
  * [Proxy](https://learn.javascript.ru/proxy) - особый объект, перехватывает обращения к другому объекту и, при необходимости, модифицирует их.
  
  **Ссылки**
  * [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/6.0/index.html) 
  * [learn.js](https://learn.javascript.ru/es-modern)
  * [code.mu](http://code.mu/books/javascript/advanced/novovvedeniya-v-es6-dlya-novichkov.html)  
    
  <br></p></details>
  
  <details><summary><b>ES5 (ECMAScript 2009)</b></summary><p>
    
  Среди изменений:
  * поддержку строгого режима (strict mode);
  * аксессоры getters и setters;
  * возможность использовать зарезервированные слова в качестве ключей свойств и ставить запятые в конце массива;
  * многострочные строковые литералы;
  * поддержка JSON.
    
  **Ссылки**
  * [Официальная спецификация (en)](http://ecma-international.org/ecma-262/5.1/)
  * [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
  * [ES5 руководство по JavaScript](https://habr.com/ru/post/281110/)
  * [Перевод спецификации EcmaScript 5 с аннотациями](https://es5.javascript.ru/)
  
  <br></p></details>
  
  <details><summary><b>Языки поверх JavaScript</b></summary><p>
    
  Синтаксис JavaScript устраивает не всех - одним он кажется слишком свободным, другим слишком ограниченным, третьи хотят добавить дополнительные возможности…
      
  Появилось много языков, которые добавляют различные возможности «поверх» JavaScript. Для запуска в браузере они превращаются в обычный JS-код (при помощи специальных инструментов «трансляторов»).
    
  Это преобразование происходит автоматически и совершенно прозрачно, при этом неудобств в разработке и отладке практически нет.
    
  Разные языки выглядят по-разному и добавляют разные вещи:
  - **CoffeeScript** – «синтаксический сахар» поверх JavaScript. Сосредоточен на большей ясности и краткости кода. Часто его любят программисты на Ruby.
  - **TypeScript** - сосредоточен на добавлении строгой типизации данных. Предназначен для упрощения разработки и поддержки больших систем. Разрабатывается Microsoft.
  - **Dart** - не только транслируется в JS, но имеет и свою независимую среду выполнения, которая даёт ему ряд возможностей и доступна для встраивания в приложения (вне браузера). Разрабатывается компанией Google.
  
  **Ссылки:**
  * [learn.javascript.ru](https://learn.javascript.ru/intro)
  
  <br></p></details>
<br></p></details>
 

#
<details><summary><b>REACT - базовые понятия </b></summary><p>

  ---
  <details>
    <summary><b>Что такое React и какие у него особенности?</b></summary><p>
   
  JS-библиотека для создания пользовательских интерфейсов.
  
  Это не фрэймворк! Cам по себе не позволит создать веб-приложение, предназначен для создания представлений (это «V» в MVC). React – это только представление. Это язык шаблонов + несколько функций, которые позволяют отрисовать HTML. Результат работы React – это HTML.
  
  Разрабатывается и поддерживается Facebook + Instagram и сообществом отдельных разработчиков и корпораций. <br>
  Открытый исходный код

  Выход первой версии: 
  - 2009 - Angular
  - 2010 - Backbone
  - 2011 - Ember
  - 2012 - Meteor
  - **2013 - REACT**
  - 2014 - Vue
  - 2015 - Polymer
  - 2015 - Aurelia
  
  Также Facebook разработал **Flux** - архитектурный шаблон, который дополняет React (см. Redux). 
  
  **Ключевые особенности:**
  - **Компонентный подход** - разбиваем страницы на небольшие фрагменты. Мы называем эти фрагменты компонентами. Их можно потом переиспользовать в других проектах.
  - **Виртуальный DOM** - React создает кэш-структуру в памяти, что позволяет вычислять разницу между предыдущим и текущим состояниями интерфейса для оптимального обновления DOM браузера. 
  - **Однонаправленная передача данных** - свойства передаются от родительских компонентов к дочерним (сверху-вниз). Компонент не может напрямую изменять свойства, но может вызывать изменения через callback функции.
  - **JSX** (JavaScript XML) - расширение синтаксиса JavaScript, "синтаксический сахар" для JS. Позволяет использовать похожий на HTML синтаксис для описания структуры интерфейса. Можно работать с React и без JSX (но не стоит)
  
  **Также:**
  - **Декларативный** - описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между этими состояниями
  - **Функциональный** - поощряется использование функционального подхода к программированию (не ООП)
  - **Реактивный** - как бы из названия видно, что является реализацией реактивного подхода к программированию
  - **Типизация** - динамическая слабая неявная (как и весь JS). Для введения статической типизации можно использовать (в порядке усложнения): propTypes / Flow / TypeScript 
  - **Тестируемость** - тут надо ещё разбираться. Но да, вроде тестируется. **//TODO**
  - **ES6** - т.к. всё равно используем Babel, логично использовать возможности ES6 (константы, стрелочные функции, шаблонные строки и т.д.)
  - **Изоморфность** - код может выполняться и на клиентской, и на серверной стороне. При первом обращении к сайту все операции выполняются на сервере и в браузер передается HTML (как обычный статический сайт). После загрузки JS сайт превращается в «одностраничное приложение», и работает соответственно.
  - **Быстрый** - в частности, потому что выполняет оптимизацию при компиляции кода в JSX -> JS
  - **Легко интегрировать** - React можно встраивать в приложение по частям: часть уже работает на React, часть без него. И всё ок. Можно подключать через CDN и т.д.
  
  **Про название**<br>
  React получил свое название от того, что он реагирует на изменения состояния (хоть и не реактивно, но по графику). Была шутка, что React должен был быть назван Schedule.
  
  **Ссылки**
  - [Angular vs. React: Сравнение 7 Основных характеристик](https://code.tutsplus.com/ru/articles/angular-vs-react-7-key-features-compared--cms-29044)
  
  <br><p></details>
  
  
  <details>
    <summary><b>Ещё разное про React</b> //ToDo - разбирать и дополнять</summary><p>
      
  **React JS и React Native**
  - React JS - js-библиотека для создания UI (2013)
  - React Native - платформа для разработки мобильных приложений, создает мобильные приложения с помощью React.js (2015)
  
  **Связывание данных**<br>
  Связывание данных - функция, которая синхронизирует данные между состоянием (моделью) приложения и представлением.
   
  - Односторонняя привязка данных  - любое изменение модели автоматически обновляет представление. Но не наоборот. 
  - Двусторонняя привязка данных - любое изменение модели автоматически обновляет представление. И наоборот. 
  
  В React однонаправленная привязка - свойства передаются от родительских компонент к дочерним ("сверху вниз"). Состояние компонента инкапсулируется и недоступно для других компонентов. Если только оно не передается дочернему компоненту в качестве props (то есть, состояние компонента становится props дочернего компонента). 
 
 Компоненты получают свойства как неизменяемые (immutable) значения. Поэтому компонент не может напрямую изменять свойства, но может вызывать изменения через callback функции. Такой механизм называют «свойства вниз, события наверх». 
  
  
  **Реактивность**<br>
  Вообще, определённый подход к созданию кода, парадигма программирования.
  Полезно почитать немного про это дело:
  - [habr - Реактивность в JavaScript: простой и понятный пример](https://habr.com/ru/company/ruvds/blog/418633/)
  - [habr - Основы реактивного программирования с использованием RxJS](https://habr.com/ru/post/438642/)
  
  **Рендеринг на стороне сервера**<br>
  - Рендеринг на стороне сервера - браузер шлёт серверу запрос, сервер присылает весь HTML-файл. Браузер только выводит его пользователю. 
  - Рендеринг на стороне клиента - браузер запрашивает у сервера много JS и сырые данные из базы. Генерация HTML идёт в браузере (клиенте).
  
  Рендеринг на стороне клиента имеет недостатки, например плох для SEO. Поэтому можно настроить React для рендеринга на сервере. React может выполняться на стороне клиента и, при этом, рендериться на стороне сервера, и эти части могут взаимодействовать друг с другом. Поэтому он широко используется для создания высокопроизводительных веб-приложений и пользовательских интерфейсов.
  
  React может рендерить компоненты сайта как на серверной, так и на клиентской стороне. Хорош для создания изоморфных приложений - позволяет переиспользовать почти весь клиентский код для рендеринга на сервере, в зависимости от масштаба приложения. Это возможно т.к.: 1) и на сервере и на клиенте используется JS; 2) и там и там не критичен реальный DOM браузера - сам React работает с вирутальным
   
  **//ToDo** - разобраться какая часть системы отвечает за преобразование JS в HTML? Скорее всего - браузер.
      
  **Babel**<br>
  Транспилятор. Преобразует JSX в обычный JS<br>
  Компоненты написанные на JSX (HTML и JS) преобразуются в чистый JS с помощью CLI (интерфейс командной строки) инструмента Babel
  
  **Webpack**<br>
  Сборщик модулей, bundler. Используется для компиляции JS-модулей.<br>
  Берёт всё, от чего зависит проект (Css, JS...), и преобразует это в статические ресурсы, которые могут быть переданы клиенту. Позволяет объединять ресурсы и библиотеки, необходимые для проекта, в один файл - «bundle» (пачка).
  
  **Create React App**<br>
  Специльное приложение от разработчиков React. По сути - готовая среа для работы, с настроенным Babel, WebPack, live development server, линтерами  и всеми чудесами. Установил - и можешь сразу начинать работать. <br>
  [GitHub](https://github.com/facebook/create-react-app)
  
  <br><p></details>
  
  
  <details>
    <summary><b>Элемент</b></summary><p>
 
  Это JS-объект, который описывает узел DOM. <br>  
  Объектное представление некоторого пользовательского интерфейса. 
    
  ```
    //Создаём элемент с помощью метода React createElement
    const element = React.createElement(
      'div',
      {id: 'login-btn'},
      'Login'
    )
    
    //Получаем такой объект (элемент):
    {
      type: 'div',
      props: {
        children: 'Login',
        id: 'login-btn'
      }
    }
    
    //Когда он будет отображён в DOM (с помощью функции ReactDOM.render), появится узел DOM
    <div id='login-btn'>Login</div>    
  ```
  
  Компонент, же - класс или функция, которая принимает данные и возвращает элементы.
  ```
  //компонент Button принимает функцию onLogin и возвращает React элемент
    function Button ({ onLogin }) {
      return React.createElement(
        'div',
        {id: 'login-btn', onClick: onLogin},
        'Login'
      )
    }
  ```
  
  Надо только учесть, что когда мы работаем с JSX - мы не видим `React.createElement`. JSX позволяет писать это проще, но по факту, переделывает в тот самый `React.createElement`
  ```
  //Примеры создания React элемента
  
  React.createElement('div', className: 'container', 'Hello!')
  
  <div className='container'>Hello!</div>
  
  <Hello />
  ```
  
  Т.е. компонент (класс/функция) генеририрует элемент (js-объект). Этот элемент будет отображён в DOM (с помощью функции ReactDOM.render), и у нас появиться новый DOM узел. А браузер на основе этого DOM-узла отобразит какую-то информацию на экране (кнопку, например)
  
  **Ссылки:**
  [React Elements против React Components](https://tuhub.ru/posts/react-elements-protiv-react-components)
        
  <br></p></details>
  
  <details><summary><b>Компонент(а)</b></summary><p>
    
  Компонент - класс или функция, которая принимает данные и возвращает элементы React.
                                                                                             
  Компонент - js-функция, которая возвращает кусок кода, представляющего фрагмент страницы. 
  Описывают DOM-элементы (h1, div, section...). Обычно это части пользовательского интерфейса, которые содержат свою структуру и функциональность. Например: NavBar, LikeButton, или ImageUploader. 
  
  Благодаря синтаксису JSX компонента совмещает и разметку, и логику<br>
  Концептуально, компоненты подобны JS-функциям - принимают данные (props) и возвращают React-элементы, описывающие что должно появиться на экране. 
  
  Когда компонент создан, автоматически появляется тэг <Имя_Компонента /> - при его помощи мы выводим этот JSX в нужном месте.
    
  Т.е. компонент (класс/функция) генеририрует элемент (js-объект). Этот элемент будет отображён в DOM (с помощью функции ReactDOM.render), и у нас появиться новый DOM узел. А браузер на основе этого DOM-узла отобразит какую-то информацию на экране (кнопку, например)
      
  **Ссылки:**
  [React Elements против React Components](https://tuhub.ru/posts/react-elements-protiv-react-components)
  
  <br></p></details>
  
  
  <details><summary><b>Virtual DOM</b> //ToDo - доработать</summary><p>
    
  Это дерево React элементов на JavaScript.
 
  На самом деле React хранит два Virtaul DOM - тот, который отражает текущее состояние React и тот, который отражает текущее состояние DOM. React сравнивает их между собой, не обращаясь к реальному DOM без крайней необходимости (т.к. чтение реального DOM - ресурсоёмкая операция) 
  
  React отрисовывает Virtual DOM в браузере, чтоб сделать интерфейс видимым. 
  React следит за изменениями в Virtual DOM и автоматически изменяет DOM в браузере так, чтоб он соответствовал виртуальному.
   
   Виртуальный DOM обновляет требуемую часть, сравнивая различия между предыдущей и текущей версией HTML. Процесс схож с тем, как Github работает при обнаружении изменений в файле.
   
   React создает кэш-структуру в памяти, что позволяет вычислять разницу между предыдущим и текущим состояниями интерфейса для оптимального обновления DOM браузера. 
   
   React считается быстрым из-за VirtualDOM. В компоненте есть метод render, который вызывается при каждом обновлении компонента. Затем результат рендера (здесь и далее под рендером будет иметься в виду именно вызов функции render компонента, а не рендер в реальный DOM) обрабатывается React, сравнивается результат текущего рендера с результатом предыдущего и в реальный DOM вносятся только необходимые изменения, а не целиком. Учитывая, что операции с реальным DOM медленные, это должно быть быстрее.
   
   Но, операции с Virtual DOM тоже могут быть медленными. Результат рендера Реакта — это многоуровневый объект. Сравнение результатов рендера — это не сравнение двух объектов по ссылке, а их полное, глубокое сравнение. 
   
   Более того, React будет делать полный перерендер компонента при любом вызове SetState (даже, если данные не поменялись) и при перерендере родителя. То есть, если у вас большое приложение, и вы вызываете setState у корневого компонента, у вас всё приложение целиком будет перерендерено. Реакт построит VDOM для всего приложения, сравнит его с предыдущим результатов и в DOM поместит те самые незначительные правки (если они даже были). Всё это приведет к значительным потерям в производительности приложения.
   
   Это решается черезе `shouldComponentUpdate` и `PureComponent`. Тут тоже есть две проблемы: 
   1. Если в стейте есть ссылочные типы. Если мутировать объект, то нет никакой возможности проверить, изменилось ли значение, так как объект в текущем и новом стейте будет ссылаться на один и тот же объект. Компонент не будет перерендериваться, хотя данные в действительности поменялись. <br>
   **Решение**: либо заменяем все мутабельные операции на аналогичные иммутабельные операции, либо создаем новую ссылку и затем уже её мутируем.
   
   2. Обратная ситуация. Когда мы каждый раз создаем ссылочный тип данных, даже если данные в нем не поменялись. Например, прогоняем данные через map - на выходе всегда новый массив, даже если данные не изменились. Получается, что у нас каждый раз создается новая ссылка, компонент будет перерендериваться, хотя не должен. <br>
   **Решение**: мемоизация (разновидность кэширования). Запоминаем предыдущие результаты вызова функции, и если вызывается снова - используем их из кэша. Есть специальные библиотеки с разной реализацией. <br>
   Важен тот момент, что так как значение берется из кеша, то возвращается та же самая ссылка. И так как у нас все данные иммутабельны, то нужна мемоизация, которая будет проверять значения по ссылке, а не глубоким сравнением
   
   Также многие забывают, что использование стрелочных функций, bind и литералов массивом \ объектов в рендере создает новую ссылку при каждом рендере. Решается использованием bind один раз в конструкторе или использованием свойств класса и выносом литералов за пределы рендера. См. подробнее: [csssr - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)
   
   
   **Ссылки**
- [Оф. документация - Виртуальный DOM и детали его реализации в React](https://ru.reactjs.org/docs/faq-internals.html)
- [Как работает Virtual DOM ?](https://medium.com/@abraztsov/how-virtual-dom-work-567128ed77e9)
- [csssr - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)
     
  <br></p></details>
  
  <details><summary><b>Props (свойства)</b></summary><p>
  
  Произвольные данные, которые принимают компоненты. Это могут быть и функции.
  
  Информация, коллективно используемая родительским компонентом и компонентами-потомками.<br> 
  Они передаются в качестве аргументов компонента. Выглядят так же, как атрибуты HTML. 
  
  Все данные в компонент приходят в первом аргументе. Обычно он называется props (от properties).
      
  Любой компонент может принимать параметры, которые потом использует внутри себя. Например, текст, который надо вывести внутри JSX-разметки, генерируемой компонентом. Главный такой параметр называется props (это просто название параметра, оно принято в React). Т.е. React, вызывая компонент, всегда передаёт в этот параметр props некий объект. Находясь внутри компонента я могу получать данные, которые пришли внутри этого props.
  
  ```      
    //Тут передаются props imageURL (значение - адрес), caption (текст), isPlaying (функция)
    <Button imageURL='http:tinyurl.comlkevsb9' caption='New York!' isPlaying={this.state.isMusicPlaying} /> 
    
  ```      
  
  <br></p></details>
  
  
  <details><summary><b>Props и производительность</b></summary><p>
  
  Основная опасность - увеличение количества render, которые мешают производительности
  
  Важно: при вызове render() перерисовывается не только родительский компонент, но и все дочерние (хотя, в них свойства могли и не поменяться). Т.е. если у родительского компонента внутри render есть дочерние компоненты - они будут перерисовываться. Соотвественно, если мы вызываем render на родительском компоненте - перерисуем всё приложение. Чтоб решить этот вопрос - используем создание компонента от PureComponent
    
  Даже если я создал класс от PureComponent - это не гарантирует отсутсвие лишних ренедров при тех же данных. Одна из причин - анонимные функци (они при каждом рендере новые). 
  ```
  //Неверно:
  render() {
    return <Component onClick= {() => this.hangleClick}>
  }
  
  //Верно:
  handleClick = () => {...}
  render() {
    return <Component onClick= {this.hangleClick}>
  }
  ```
  
  То же самое с объектами - не создаём их прямо в функции, а подключаем как константу
  
    ```
    //Неверно:
    render() {
      return <Component test= {{a: 1}}>
    }
    
    //Верно:
    const obj = {a:1}
    render() {
      return <Component test= {obj}>
    }
    ```
  
 **Ссылки**
  - [YouTube - Какие props портят производительность](https://www.youtube.com/watch?v=zSDOxWhPG_U)
  
  <br></p></details>
  
  
  <details><summary><b>State (состояние)</b></summary><p> 
    
  Специальный js-объект внутри компонента. Хранит данные, которые могут изменятся с течением времени.<br>
  Описывает внутреннее состояние компонента. 
  
  - Props - входные данные, которые передаются в компонент извне. 
  - State - хранит данные, которые создаются в компоненте и полностью зависят от компонента. Определяется внутри компонента и доступно только из компонента. Компонент может передать своё состояние дочерним компонентам в виде props.
  
  Также, в отличие от props, значения в state можно изменять. 
  
  
  С добавлением Redux всё становится немного интереснее, т.к. Redux вводит свой state. Он собственно и нужен для управления state приложения.(см. Redux)
  
  **Как правильно использовать state**
  - Не изменяйте состояние напрямую. Вместо этого используйте setState()
  ```
  // Неправильно
  this.state.comment = 'Привет';
  
  // Правильно
  this.setState({comment: 'Привет'}); 
  ``` 
  - Обновления состояния могут быть асинхронными. Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.
  - Обновления состояния объединяются. Когда мы вызываем setState(), React объединит аргумент (новое состояние) c текущим состоянием. Состояния объединяются поверхностно. 
  
  **Ссылки**
  - [оф. документация](https://ru.reactjs.org/docs/state-and-lifecycle.html)
    
  <br></p></details>
  
    
  <details>
    <summary><b>Композиция в React</b></summary><p>
    
  Комбинирование меньших компонентов при формировании большего.
      
  <br></p></details>
  
  <details><summary><b>Reverse Data Flow - обратный поток данных</b></summary><p> 
  
  Изменение state родительского компонента из его компонента-потомка.
  
  Например такая картина:
  - есть два компонента: Родитель и Потомок
  - в Родителе хранится состояние (например цвет фона)
  - в Потомке происходит что-то, что должно поменять состояние Родителя (например, нажата кнопка)
  - Как из дочернего компонента повлиять на состояние родительского?
  
  Делаем так:
  - в Родителе кроме state определяем функцию для изменения этого state
  - эту функцию передаём в виде колбэка Потомку (через props)
  - Потомок вызывает колбэк, тот отрабатывает в Родителе, и там меняется состояние
  
  **Другими словами**<br>
  В React обычным является кода родитель управляет потомком. Так же часто надо управлять родителем из дочернего компонента. Такой подход как раз и называется "Обратный поток данных".
  
  В родительском компоненте, там где хранится состояние, хранится и обработчик этого события. Нужно только передать этот обработчик в дочерний компонент в качестве props. В дочернем компоненте, в нужный момент я просто подставлю эту функцию из props, и отработает изменение состояния в родительском компоненте.
  
  **Ссылки**
  - [React. 1 . Props, State, Жизненный цикл, Reverse Data Flow](https://vk.com/@489914144-react-vvedenie)
  
  <br></p></details>
  
  <details>
    <summary><b>State lifting - подъём состояния</b></summary><p>
    
  Перенос данных / функций из дочернего элемента в родителя, чтоб они были доступны нескольким потомкам. 
  А из потомка вызываю эти обработчики как коллбэки (через props) или получаю эти данные в виде props.
  
  Если несколько компонентов должны отражать одни и те же изменяющиеся данные - поднимаем общее состояние до ближайшего общего предка. 
  
  **Ссылки**
    - [Оф. документация - Подъём состояния](https://ru.reactjs.org/docs/lifting-state-up.html)
  
  <br></p></details>
  
  <details>
    <summary><b>Key</b> //ToDo - доработать</summary><p>
    
  Атрибут, особое уникальное свойство элемента. Связывает данные и элементы React.<br>
  Если быть точным - это special props. Не включается в объект props и недоступно внутри самого компонента.
  
  Например, если надо удалить одну статью из 10 - React удалит только статью с нужным key, а остальные перестраивать не будет. 
   
  Ключи помогают React идентифицировать, какие элементы были изменены, добавлены или удалены. Ключи должны быть заданы элементам внутри массива, чтобы предоставить элементам постоянный идентификатор. 
  
  Ключи оптимизируют работу с элементами массивов, уменьшают количество ненужных удалений и созданий элементов. 
  
  При использовании ключей важно понимать, что при смене данных ключи должны меняться. Яркий пример ошибки- использование индекса элемента в массиве как key. Но массив изменится, а индекс останется тот же...
  
  Лучший способ выбрать ключ — использовать строку, которая однозначно идентифицирует элемент списка среди его соседних элементов. Идеальные ключи должны браться из самих данных - id, уникальный title или ещё что-то в этом роде.
  
  Главная задача ключей в реакте — помогать механизму reconciliation. Без key механизм reconciliation сверяет компоненты попарно между текущим и новым VDOM. Из-за этого может происходить большое количество лишних перерисовок интерфейса, что замедляет работу приложения. Добавляя key, вы помогаете механизму reconciliation тем, что с key он сверяет не попарно, а ищет компоненты с тем же key (тег / имя компонента при этом учитывается) — это уменьшает количество перерисовок интерфейса. Обновлены/добавлены будут только те элементы, которые были изменены/не встречались в предыдущем дереве.
      
   **Ссылки**
   - [Оф. документация - Списки и ключи](https://ru.react.js.org/docs/lists-and-keys.html)   
   - [Оф. документация - Согласование](https://ru.reactjs.org/docs/reconciliation.html#recursing-on-children)
   - [habr - подробная статья](https://habr.com/ru/company/hh/blog/352150/)   
   - [YouTube - Отображение массивов, смысл аттрибута key](https://www.youtube.com/watch?v=tn9HyYRVZ9A)   
      
  <br></p></details>
  
  <details>
    <summary><b>Refs</b> //ToDo - доработать</summary><p>
 
  Аттрибут HTML-элемента или классового компонента.<br>
  Если быть точным - это special props. Не включается в объект props и недоступно внутри самого компонента.<br>
  От reference - ссылка.
 
  Используются для получения ссылки на узел DOM или компонента в React. 
  Refs возвращает ссылку на элемент. Почти как старые добрые getElementById.
 
  React.JS refs нужен чтоб понадобилось «достучаться» к конкретному элементу и вызвать метод. Добавляем атрибут ref в компонент для обратного вызова. 
  
  Полезно в нескольких случаях.<br> 
  Например: 
  - вы хотите прочитать значение элемента без React
  - навесить jQuery библиотеку на элемент
  - вызвать какой-то нативный метод - например focus.
  
  В обычном потоке данных React родительские компоненты могут взаимодействовать с дочерними только через пропсы. Чтобы модифицировать потомка, вы должны заново отрендерить его с новыми пропсами. Но, могут возникать ситуации, когда вам требуется императивно изменить дочерний элемент (React-компонентом или DOM-элемент), обойдя обычный поток данных. Для этого есть refs
  
  Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента. Refs становятся доступны после метода render и перед componentDidMount.
  
  **Почему бы не брать ссылку по ID элемента?**
  - Под каждый элемент должна быть уникальная id, тогда как названия ref могут повторяться в разных компонентах.
  - Это противоречит “философии” React.
    
  **Best Practise**
  - Выносите функции для получения ref в методы
  - Не используйте string рефы (старый синтаксис ref)
  
  **Избегаем использования**
  Старайтесь не использовать, если в них не реальной необходимости.
  
  Ref отличный способ доступа к DOM элементам, но его нужно применять с осторожностью. Это не React way, а просто возможность доступа к DOM элементам. Если это возможно - лучше использовать state или props вместо refs, так как они поддерживают правильный поток данных в приложении, а refs нет.
  
  Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом. Например, вместо того чтобы определять методы open() и close() в компоненте Dialog, лучше передавать ему проп isOpen
  
  **Применение оправдано**
  - Управление фокусом, выделение текста или воспроизведение медиа.
  - Анимации.
  - Интеграция с DOM библиотеками.
  
   **Ссылки**
   - [Оф. документация - Рефы и DOM](https://ru.reactjs.org/docs/refs-and-the-dom.html)
   - [monsterlessons.com](https://monsterlessons.com/project/lessons/react-refs)
   - [Refs в React: Всё что нужно знать](https://medium.com/@abraztsov/refs-%D0%B2-react-%D0%B2%D1%81%D1%91-%D1%87%D1%82%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-266a979690f8)
   
  <br></p></details>
    
  <details><summary><b>Среда React</b></summary><p>
    
  Для работы используется:
  - **NPM/Yarn** - для управления зависимостями. Ну, и чтобы установить Create React App (для работы npm нужен Ruby)
  - **Babel**
  - **WebPack** 
  - **WebPack server** 
  - **Create React App** - специальная npm/yarn утилита дл ябыстрого развоарчивания проекта на React. Содержит Babel, WebPack и прочее
  - OpenServer не нужен!
  
  Вообще, можно без всего этого добра - добавить в код ссылку на CDN Реакта и всё. Но с "добром" удобнее.
  
  <br></p></details>
    
  <details>
    <summary><b>React + Bootstrap</b></summary><p>
    
   C Bootsrap в React можно работать как в чистом виде, так и при помощи специальных react-библиотек, которые интегрируют Bootstrap в React. 
   
  <br></p></details>
    
  <details>
    <summary>Создание приложения обычно выглядит так:</summary><p>
    
  - есть некий дизайн (UI)
  - глядя на него, я начинаю общаться с заказчиком, и разбираться - какие данный приходят на ту или иную страницу, какие с ними действия происходят, и т.д.
  - на основе этого я формирую state для каждой из страниц. Формирую BLL - Busines Logic Layer
  - параллельно решаю вопрос как управлять state (state managment)
  - только потом начинаю кодить компоненты UI и связывать их со state
      
  <br></p></details>
    
  <details>
    <summary>устанавливая пакет - дописывать в конце --save Означает, что нужно внести запись в package.json</summary>
      npm install react-router-dom --save
  </details>
    
  <details>
    <summary>Отладка React - какие есть методы?</summary><p>

  - React devtools поставляется в двух видах
    - отдельным пакетами
    - расширением для популярных браузеров. В расширении можно увидеть изменения состояний приложения и узлы виртуального DOM-дерева.
  - console.log()
    Иногда хочется отлаживать по старинке, с помощью console.log(). 
    Можно получить значение переменной внутри JSX прямо в точке её применения.
      <img src={console.log('logo', logo) || logo} />
    Как это работает: 
      console.log() вернет undefined и код выполнится дальше по условию "||", 
      а в консоли браузера мы увидим искомое значение, например: "/static/media/logo.5d5d9eef.svg".
  - (() => { debugger })() || // anything
  - Отладка внутри IDE WebStorm
    - Установите расширение Chrome — JetBrains IDE Support. 
    - Добавьте Run/Debug-конфигурацию.
    - Запустите create-react-app через терминал командой: $ yarn start
    - Выберите конфигурацию Debug и нажмите кнопку с иконкой жука (в правом верхнем углу IDE)
    - Откроется браузер с предупреждением "JetBrains IDE Support отлаживает этот браузер". Замечено, что если теперь открыть Chrome DevTools по [F12], то отладка в WebStorm завершится — не надо этого делать)
    -  можно отметить нужную строчку кода, как точку останова, затем перегрузить страницу браузера по [F5], и получить желаемое — инструмент отладки внутри WebStorm.
    
  <br></p></details>
  
  
   <details>
        <summary>В React мы никогда не лезем в DOM напрямую.</summary>
        Никаких getElementById и т.д. Мы работаем с VirtualDOm, а уже сам React занимается связкой Virtual DOM & DOM
    </details>
    
  <details>
      <summary>Избегать циркулярных (циклических) зависимостей</summary>
      когда , например,  файл  a.js импортирует в себя файл b.js, и при этом внутри b,js есть импорт файла a.js. То есть фалы импортируются друг в друга. Это говнокод, идущий в разрез с принципами функционального программирования. Т.е не должно быть именно взаимных импортов. 
      Но, можно вызвать функцию из другого файла, и в качестве данных отдать в неё свою функцию. Т.е. использовать callback.
      https://www.youtube.com/watch?v=iN6QXbHedQc
  </details>
  
  <details>
    <summary>Как правильно получать данные из html-элемента (без использования ref)</summary>
        let onQuoteChanged = (event) => {
          let text = event.target.value;
        };
        return (
              <textarea onChange={onQuoteChanged} />
        }
  </details>
  
  <details>
    <summary>Избегать изменения элементов/данных по ссылке</summary>
      https://www.youtube.com/watch?v=NhT5nMvve4Q
      мы не знаем где ещё он используется. 
      работать надо с локальными переменными. 
      Никогда не менять внешние переменные, и тем более - ничего, что приходит в props. 
      Работать с иммутабельными данными (теми, которые не меняются по ссылке). Если нужно поменять что-то - мы не меняем по ссылке локальную переменную (например массив), а создаём новый массив с нужными параметрами

  - Про JS-Объекты (и массивы). При копировании объект в памяти остаётся то же, на него просто создаётся новая ссылка. 
    Поэтому, если измнеить что-то в объекте-копии, оригинальный объект тоже изменится (т.к. у нас есть только один объект, с двумя разными ссылками на него).
    Если объект одноуровневый - можно сделать его полноценную копию так (через спред-оператор):
    newObject = {...oldObject}
    Но, если в объекте oldObject были вложенные объекты/массивы - они передадутся опять по ссылке, а не создадут полноценной копии.
  </details>
  
  <details>
    <summary>При работе с функциями, мы передаём фактическую ссылку на функцию, а не строку.</summary>
  </details>
  
  <details>
    <summary>Передача аргументов в обработчики событий</summary>
  https://ru.reactjs.org/docs/handling-events.html

  Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. 
  Например, если id — это идентификатор строки, можно использовать следующие варианты:

  <button onClick={(e) => this.deleteRow(id, e)}>Удалить строку</button>
  <button onClick={this.deleteRow.bind(this, id)}>Удалить строку</button>

  Две строки выше — эквивалентны, и используют стрелочные функции и Function.prototype.bind соответственно.

  В обоих случаях аргумент e, представляющий событие React, будет передан как второй аргумент после идентификатора. Используя стрелочную функцию, необходимо передавать аргумент явно, но с bind любые последующие аргументы передаются автоматически.
  </details>
  
  **Ссылки:**
  - [Оф. документация - обучение теоретическое](https://ru.reactjs.org/docs/)
  - [Оф. документация - обучение практическое](https://ru.reactjs.org/tutorial/tutorial.html)
  - [IT Kamasutra - лучший курс видео. Большой](https://www.youtube.com/channel/UCTW0FUhT0m-Bqg2trTbSs0g)
  - [http://code.mu - курс. Должен быть неплох](http://code.mu/books/advanced/javascript/react/)
  - [learn.javascript.ru - вводный курс видео. Короткий](https://learn.javascript.ru/screencast/react)
  - [monsterlessons.com - вводные уроки. Видео + текст. Примерно 2017](https://monsterlessons.com/project/series/react-dlya-nachinayushih)
  - [какой-то кур](https://habr.com/ru/company/ruvds/blog/432636/)
  
<br></p></details>

#
<details><summary><b>REACT - компоненты</b></summary><p>
  
  ---
  <details><summary><b>Названия компонент начинаются с Заглавной буквы</b></summary><p>
    
  Это важно, так как в работе будут сочетаться HTML-элементы и элементы React. <br>
  Названия со строчных букв зарезервированы для HTML. Если вы попробуете назвать элемент просто button, при рендере фреймворк проигнорирует его и отрисует обычную HTML-кнопку.
  
  <br></p></details>
  
  
  <details><summary><b>Компоненты = чистые функции</b></summary><p>
     
  React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.<br>
  Чистые функции не пытаются ничего изменить и всегда отдают тот же результат (при условии, что на вход подаются одни и те же данные).
  
  Функция не должна работать ни с какими глобальными объектами или генерировать данные. Всё с чем она работает - только с тем, что приходит в неё через props (т.е. через параметры функции). 
  
  Такие функции не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов. Возвращаемая разметка должна зависеть только от входящих значений props - если 100 раз вызвать функцию с одними и теми же значениями props, мы 100 раз получим один и тот же результат.
  
  State даёт компонентам возможность реагировать на действия пользователя, ответы сервера и другие события, не нарушая чистоту компонента. 

  **Как поддреживать чистоту компонент:**  
  - Никогда не менять по ссылке внешние (глобальные) переменные, массивы и т.д.<br> 
    Не сортировать и вообще не трогать. Особенно то, что приходит в props.<br> 
    Если надо изменить - создавай в компоненте отдельную переменную, записывай в неё, и её меняй.<br> 
    
  - Пропсы можно только читать!<br>
    Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
    
  Пример чистой функции -  не меняет свои входные данные и предсказуемо возвращает один и тот же результат для одинаковых аргументов:
  ```
    function sum(a, b) {
      return a + b;
    }
  ```    
    
  Пример нечистой функции — записывает данные в свои же аргументы:
  ```
  function withdraw(account, amount) {
      account.total -= amount;
    }
  ```
  
  Смотри подробнее в секции "Чистые функции"
    
  **Ссылки**
  - [Оф. документация - Компоненты и пропсы](https://ru.reactjs.org/docs/components-and-props.html)
  - [YouTube - Отладка React-приложений (javascript.learn)](https://www.youtube.com/watch?v=NhT5nMvve4Q)
    
  <br></p></details>
  
  
  <details><summary><b>Компоненты и Props</b> //ToDo  - доработать</summary><p>
 	
  Произвольные данные, которые принимают компоненты. Это могут быть и функции.
 	
  Информация, коллективно используемая родительским компонентом и компонентами-потомками.<br> 
  Они передаются в качестве аргументов компонента. Выглядят так же, как атрибуты HTML. 
  
  Все данные в компонент приходят в первом аргументе. Обычно он называется props (от properties).
      
  Любой компонент может принимать параметры, которые потом использует внутри себя. Например, текст, который надо вывести внутри JSX-разметки, генерируемой компонентом. Главный такой параметр называется props (это просто название параметра, оно принято в React). Т.е. React, вызывая компонент, всегда передаёт в этот параметр props некий объект. Находясь внутри компонента я могу получать данные, которые пришли внутри этого props.
  
  ```      
    //Тут передаются props imageURL (значение - адрес), caption (текст), isPlaying (функция)
    <Button imageURL='http:tinyurl.comlkevsb9' caption='New York!' isPlaying={this.state.isMusicPlaying} /> 
    
  ```      
  
  Чтоб при вызове компонента передать что-то в его props - достаточно прописать некий атрибут, например name='Dima' превратится в props.name
   
  ```
    const User = (props) => {
      return (
        <p> {props.name} </p>
        <p> {props.age} </p>
      )
    }
  
    <User name='Dima' age='30' />
  ```

  **UNSORTED**
    
  Props = объект, который позволяет передать в компонент какие-то данные. Или предать callback - функцию, которая компонента потом сможет запустить. Т.е. сама функцию создана в одном файле, но если передать её через props - вызывается из другого файла
    
  Правильный подход - прокидывать в компоненты как можно меньше лишней информации props. Чтоб компоненты оставались "чистыми", "презентационными". Чтоб, в идеале, компонента ничего не знала про store - чтоб мы никак не были завязаны на store, тогда в будущем можно использовать эти компоненты с другими реализацями state-managmant (MobX, ...)
    
  Первый аргумент функции, создающей компонент. В него приходят все данные, с которыми мы работаем в компоненте.
    
  Каждый элемент имеет список свойств (атрибутов), как и в HTML. В Реакте это называется props.
    
  Пропсы можно только читать!<br>
  Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
    
  **Ссылки**
  - [Оф. документация - Компоненты и пропсы](https://ru.reactjs.org/docs/components-and-props.html)
    
  <br></p></details>
  
  
  <details><summary><b>Компоненты контейнерные и презентационные (умные/глупые)</b> ToDo - доработать</summary><p>

  Два типа компонент по типу задач, которые выполняют.
  
  **Контейнерная**
  
  Отвечает за данные и операции с ними. Например, берёт на себя общение со Redux или AJAX запросы.<br> 
  Позволяет поддерживать внутреннюю (глупую) компоненту чистой.
  
  Всегда работают как обёртка вокруг другой компоненты - контейнерной или презентационной. <br>
  Обычно не содержат разметки и не имеют CSS-стилей. Их задача - делать грязную/сложную работу (запросы и т.д.), а не отрисовывать данные.

  Их часто создают с использованием react-redux, они могут осуществлять диспетчеризацию действий Redux.
  
  **Презентационная**

  Отвечает лишь за отрисовку полученных данных. И передачу в систему данных от пользователя (клик мышкой, ввод текста...)<br>
  Не осведомлены о состоянии Redux и прочем. Обычно содержат DOM-разметку (JSX, HTML...)
  
  Часто обрачиваются контейнерными компонентами, которые берут на себя общение со Store и прочую логику. А презентационная компонента остаётся чистой, мало знает об окружении, не сильно с ним связана => может быть легко переиспользована в другом проекте. И легко протестированна.
  
  Могут быть обёрнуты контейнерной компонентой, либо работают без них (сами по себе)
  
  Получают данные через свойства и могут вызывать коллбэки, которые также передаются им через свойства. Не должны изменять данные. 
  
  Подробнее:
  - Отвечают за внешний вид 
  - Могут содержать как другие presentation компоненты, так и контейнеры
  - Поддерживают слоты (Often allow containment via this.props.children)
  - Не зависят от приложения (Redux и т.д.)
  - Не зависят от данных 
  - Интерфейс основан на props
  - Часто stateless, т.е. не имею своего состояния
  - Часто функциональные
  
  
  **UNSORTED**
  
  Контейнерная компонента - обёртка вокруг презентационной компоненты, чтоб сохранить её чистой (не зависимой от props, store, state...)</summary>
  Тогда презентационную можно будет пере-использовать в других проектах и т.д.  
  Т.е. чтоб презентационная компонента не использовала actionCreator из dispatch и прочее. 
  Вместо этого мы всё получаем через props, а вместо dispatch используем callbacks. 
    
  С другой стороны, если бы контейнерной компоненты не было - нам нужно было бы каждый callback прокидывать из store через всё дерево в каждую презентационную компоненту. Это неудобно. 
  Поэтому мы до контейнерной компоненты прокидываем обычный dispatch + state, в ней вызываем отрисовку чистой презентационной компоненты, и передаём ей (через props) из этого dispatch колбэки и state.
  
  Контейнерная компонента общается со Store через context API (https://ru.reactjs.org/docs/context.html)
  
  - Контейнерная компонента - берёт на себя общение со Store (ООП-объект, хранящий state). 
      И позволяет поддерживать внутреннюю компоненту чистой
      Прокидывает в неё данные из Store (props, dispatch колбэки) 
        отрисовывает презентационную компоненту
  
  - Если кратко, компоненты-контейнеры отвечают за данные и операции с ними. Их состояние передается в виде свойств в компоненты-представления и отображается.
  
    - Организация контейнерных компонент и AJAX 
    - снаружи - контейнерная, которая через connect работает со Store
    - в ней (в том же файле) - классовая, которая делает AJAX-запросы и прочие сайд-эффекты
    - классовая вызывает отрисовку функциональной (которая лежит в отдельном файле). Та получает только props и отдаёт JSX

   Презентационная компонента - чистая компонента, получает props, отдаёт JSX.
  Всё получает через props (из контейнерной компоненты), а вместо dispatch используем callbacks. 
  
      - smart-компоненты - манипулируют данными
      - dumb-компоненты - что-то отрисовывают
  
  **Ссылки:**
  - [Презентационный компонент и контейнер в React](https://medium.com/@kanby/%D0%BF%D1%80%D0%B5%D0%B7%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82-%D0%B8-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80-%D0%B2-react-f0e118480809)
  - [Stateful и Функциональные stateless компоненты в React](https://code.tutsplus.com/ru/tutorials/stateful-vs-stateless-functional-components-in-react--cms-29541)
            
  <br></p></details>
  
  
  <details><summary><b>Компоненты с состоянием и без (stateful/stateless)</b></summary><p>
    
   Некоторые компоненты используют в React метод setState(), а некоторые нет.<br>
   - Stateful - компоненты имеющие состояние (state). Всегда являются классовыми компонентами (у функциональных своего state нет). 
   - Stateless - компоненты без состояния. Могут быть и функциональными и классовыми. 
   
  **Ссылки:**
  - [Stateful и Функциональные stateless компоненты в React](https://code.tutsplus.com/ru/tutorials/stateful-vs-stateless-functional-components-in-react--cms-29541)
  
  <br></p></details>
  
  
  <details><summary><b>Компоненты классовые и функциональные</b> //ToDo - доработать</summary><p>
    
  **Функциональные** (Functional components) - простые компоненты, созданные как функции.<br>
  React - функционально-ориентированная библиотека, так что рекомендуется использовать эти компоненты, там где можно. Кстати, они появились позже 
   ```
    //Создаются так:
    const Welcome = (props) => {}
    
    //Или так:
    function Welcome(props) {}
   ```
    
   **Классовые** (Class-Components) - объявлены как класс, имеют методы жизненного цикла, локальное состояние, refs и многие другие штуки. <br>
   Без лишней необходимости их лучше не использовать. С появлением хуков вообще становятся менее востребованны.
   ```
    //Создаются так:
    class Welcome extends React.Component {}
    
    //Или так:
    class Welcome extends React.PureComponent {}
   ```
   
   
   **UNSORTED**
   
  Есть два типа компонентов
    - функциональные - states - очень простые (тупые), без состояний (presentational, stateless, dumb). Это функция, которая принимает props и возвращает JSX
    - классовые - с использованием классов ES6 - с состояниями. Можно использовать методы жизненного цикла. Необходимы, если компонент имеет состояние или значимые методы.
    
  React-разработчики стараются минимизировать использование классовых компонент. Если можно решить вопрос функциональной компонентой - так и делай
    
  Есть два типа синтаксиса
  - функциональные компоненты. 
      Для очень простых компонентов, почти без логики (stateless компоненты):
          import React, {Component} from 'react';
          function Article(props) {}
              
  - классовый компонент (классы компонентов). 
      Позволяет использовать дополнительные возможности, такие как локальное состояние и методы жизненного цикла.
      Наследуется от базового компонента Component
      Должны содержать функцию render()
      Компоненты, основанные на классах, могут хранить информацию о текущей ситуации. Эта информация называется состоянием (state), она хранится в JS-объекте.
          
          import React, {Component} from 'react';
          class Article extends PureComponent {
            render () {}
          }
          
          метод render нужен обязательно, он отвечает за то, как будет выглядеть компонент.
          props будет жить в this.props   
   
    **Классовые компоненты**
  
  Класс, который наследуется от метода React.Component, у которого есть как минимму метод render, и который возвращает JSX
  
  
  Для чего нужны классы? Чтоб создавать однотипные объекты на базе этих классов и реализовать в них концепции ООП (инкапсуляция, полиморфизм, наследование)
    - Полиморфизм - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
    - Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
    - Инкапсуляция – сокрытие деталей. Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.
    - Абстрагирование – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.
  
  Методы и обработчики классовых компонент писать так (кроме render): onClick = () => {}
  
      https://www.youtube.com/watch?v=vO63wxg4aKY
  
      Позволяет решить вопросы c контекстом вызова (bind и т.д.) - 
      Не забыть, что все обработчики (практически все) объявляются внутри классовой компоненты, как её метод
  
   setState - метод компонента. Обновляет его состояние, и вызывает перерисовку
   
      Вызов setState позволяет React перестроить ваше приложение и обновить DOM.
      Обычно когда необходимо обновить компонент вы просто вызываете setState с новым значением переданным в виде объекта в функцию setState: 
        this.setState({someField:someValue})
  
   setState - использование стрелочной функции вместо объекта
   
        https://clck.ru/GDfFh
        раньше: setState(nextState)
        теперь: setState((s,p) => s) 
  
        позволяет использовать текущее состояние this.State, не опасаясь, что произойдёт что-то не то.  
        То есть: позволит получить вам достоверные значения для state и props компонента. 
        Иначе: так как this.props и this.state могут обновляться асинхронно, то не стоит полагаться на их значения для вычисления нового состояния. 
        Т.е. я хочу просто инвертировать свойство внутри state (например open/close), и делаю !this.state.isOpen. Но, к моменту выполнения кода этот параметр может уже измениться из другого места, и я получу неожиданный результат
  
   Обновления state могут быть асинхронными
   
        React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.
  
        Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.
  
        Например, следующий код может не обновить счётчик:
  
        // Неправильно
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
  
        Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:
  
        // Правильно
        this.setState((state, props) => ({
          counter: state.counter + props.increment
        }));
  
  Set State перестраивает весь виртуальный DOM компонента, на котором он вызван. 
  
        И всех его вложенных компонентов! А потом вносятся изменения в реальный DOM. 
        Поэтому - если нет необходимости - не вызывай изменения set state у родителей, чтоб лишний раз не перестраивать виртуальный DOM всех их потомков. Т.е. верхние уровни задействуем только тогда, когда это нужно
  
      - Какой второй аргумент может быть передан в setState? Это функция обратного вызова, вызовется когда элемент отрендерен
        Это функция обратного вызова. 
        Она реализовывается строго после setState, когда элемент отрендерен, и является полностью опциональной. 
        Рекомендуется отдать предпочтение другому методу, нежели данной функции, но знать о ее существовании и принципе работы не помешает:
          
        this.setState(
          { username: 'tylermcginnis33' },
          () => console.log('setState has finished and the component has re-rendered.')
        )   
   
   
  <br></p></details>
  

  <details><summary><b>Компоненты контролируемые и не контролируемые</b> (controlled и uncontrolled) //ToDo - доработать</summary><p>
    
  **Контролируемые** -  работают через state, получают и пишут данные обычно в state. 

  **Неконтролируемые** - работают напрямую с виртуальным DOM деревом, обычно через ссылку ref. 

  Дух React делает упор на контролируемых компонентах. 
  
  В HTML элементы формы, такие как input, textarea и select, как правило, поддерживают свое собственное состояние и обновляют его на основе пользовательского ввода. Когда пользователь отправляет форму, значения из элементов, упомянутых выше, отправляются вместе с формой. 

  В React это работает по-другому. 
  Компонент, содержащий форму, будет отслеживать значение ввода в своем состоянии и повторно визуализировать компонент каждый раз, когда вызывается функция обратного вызова onChange, например, при обновлении состояния. 

  Элемент ввода формы, значение которого контролируется React, таким образом называется «контролируемым компонентом».

  <br></p></details>
  
  <details><summary><b>PureComponent</b> //ToDo - доработать</summary><p>
  
  Особый способ создания классовых компонент.<br>
  Изменяет lifecycle-метод shouldComponentUpdate, автоматически проверяя, нужно ли заново отрисовывать компонент.

  PureComponent будет вызывать функцию render(), только если обнаруживает изменения в props или в состоянии. 
  В некоторых случаях React.PureComponent более эффективен и определенно уменьшает количество кода.
    
  По сути, вариант реализации метода shouldComponentUpdate - поверхностно сравниваются все старые/новые property и все старые/новые state. Если хоть что-то поменялось - перерисовываем компонент
    
  Разница между Component и PureComponent заключается в методе updating lifecycle: shouldComponentUpdate.<br> 
  Component не реализует shouldComponentUpdate(), PureComponent реализует его поверхностным сравнением пропсов и состояния.
   
  В Component этот метод выглядит так:
  ```
  shouldComponentUpdate() {
   return true;
  }
  ```
  
  В PureComponent:
  ```
  shouldComponentUpdate(nextProps, nextState) {
   return !shallowEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);
  }
  ```
    
  Что такое shallowEqual? Это по сути сравнение оператором === каждого элемента из prevProps с каждым элементом из nextProps.   
    
  Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). 
  
  Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние, или используйте forceUpdate(), когда знаете, что вложенные структуры данных изменились. Также подумайте об использовании иммутабельных объектов, чтобы упростить процесс сравнения вложенных данных.
  
  Кроме того, метод shouldComponentUpdate() базового класса React.PureComponent пропускает обновление пропсов для всего поддерева компонентов. Убедитесь, что все дочерние компоненты также являются «чистыми».
  
  Важное замечание: PureComponent нужно использовать только для так называемых presentational components, т.е. для тех компонент, которые НЕ обёрнуты в вызов redux connect().
  
  Для container components (т.е. тех компонент, которые обёрнуты в redux connect()) нет смысла наследоваться от PureComponent, т.к. метод connect() оборачивает ваш компонент своей реализацией shouldComponentUpdate, которая также использует shallowEqual. Если вы по недосмотру унаследуете container component от PureComponent - ошибок не будет, но это не имеет никакого смыла, т.к. ваш код по сути будет дважды делать shallowEqual, а зачем делать лишнюю работу?


  Важно помнить, что PureComonent пропускает отрисовку не только самого компонента, но и всех его “детей”, так что безопаснее всего применять его в presentational-компонентах, без “детей” и без зависимости от глобального состояния приложения. 
  
  В случае, если pure-компонент имеет детей, все дочерние компоненты, зависящие от смены контекста, не будут реагировать на изменения, если в родительском pure-компоненте не будет объявлен contextTypes.
  
  **UNSORTED**
  
  
  Важно: при вызове render() перерисовывается не только родительский компонент, но и все дочерние (хотя, в них свойства могли и не поменяться). Т.е. если у родительского компонента внутри render есть дочерние компоненты - они будут перерисовываться. Соотвественно, если мы вызываем render на родительском компоненте - перерисуем всё приложение. Чтоб решить этот вопрос - используем создание компонента от PureComponent
  
  Даже если я создал класс от PureComponent - это не гарантирует отсутсвие лишних ренедров при тех же данных. Одна из причин - анонимные функци (они при каждом рендере новые). 
  ```
  //Неверно:
  <Component onClick= {() => this.hangleClick}>
  
  //Верно:
  <Component onClick= {this.hangleClick}>
  ```
  
  автоматически проверяет, должен ли компонент обновляться. Не нужно писать shouldComponentUpdate самостоятельно.

  PureComponent будет вызывать функцию render(), только если обнаруживает изменения в props или в состоянии. 
  В некоторых случаях React.PureComponent более эффективен и определенно уменьшает количество кода.

  Если в props вы передаёте объекты которые иногда мутируются, т.е. по ссылке они равны ===, но внутри какие-то данные поменялись (что само по себе выглядит странно в экосистеме redux + reselect, но вполне возможно технически), тогда использование PureComponent вам всё поломает, т.к. на экране какие-то компоненты перестанут перерисовываться!

  Если же у вас всё по уму, данные которые передаются через props являются скалярными типами (string, int, float, bool) или immutable объектами, тогда смело используйте PureComponent - в некоторых случаях он поможет избавиться от лишних вызовов render.

  Важное замечание: PureComponent нужно использовать только для так называемых presentational components, т.е. для тех компонент, которые НЕ обёрнуты в вызов redux connect().

  Для container components (т.е. тех компонент, которые обёрнуты в redux connect()) нет смысла наследоваться от PureComponent, т.к. метод connect() оборачивает ваш компонент своей реализацией shouldComponentUpdate, которая также использует shallowEqual. Если вы по недосмотру унаследуете container component от PureComponent - ошибок не будет, но это не имеет никакого смыла, т.к. ваш код по сути будет дважды делать shallowEqual, а зачем делать лишнюю работу?

  По сути, вариант реализации метода shouldComponentUpdate - поверхностно сравниваются все старые/новые property и все старые/новые state. Если хоть что-то поменялось - перерисовываем компонент

  Подводя итог, рецепт такой:
    - presentational components наследуем от React.PureComponent
    - container components (которые обёрнуты в redux connect()) наследуем от старого доброго React.Component 

  Важно помнить, что PureComonent пропускает отрисовку не только самого компонента, но и всех его “детей”, так что безопаснее всего применять его в presentational-компонентах, без “детей” и без зависимости от глобального состояния приложения. 
  В случае, если pure-компонент имеет детей, все дочерние компоненты, зависящие от смены контекста, не будут реагировать на изменения, если в родительском pure-компоненте не будет объявлен contextTypes.

  **Ссылки**
  - [Оф. документация - React.PureComponent](https://ru.reactjs.org/docs/react-api.html#reactpurecomponent)
  - [habr - Разбор: как и зачем применять PureComponent в React](https://habr.com/ru/company/redmadrobot/blog/318222/)
  - [PureComponent и Components](https://medium.com/frontend-notes/purecomponent-%D0%B8-components-5c15cf206ba7)
  - [csssr - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)
  - [YouTube - Какие props портят производительность](https://www.youtube.com/watch?v=zSDOxWhPG_U)
  - [totser](https://toster.ru/q/384870)
  - [habr - Оптимизация производительности в React](https://habr.com/ru/post/319536/)
          
  <br></p></details>
 
 
  <details><summary><b>Компоненты высшего порядка</b> (Higher Order Components, HOC) //ToDo - доработать</summary><p>
  
  Способ повторного использования логики.
  
  Это функция, которая принимает компонент и возвращает новый контейнерный компонент (функциональный или классовый).
  
  Благодаря HOC мы можем создавать одотипные контейнерные компоненты, передававя в них презентационные компоненты (которые надо обернуть)
  
  Если функция возврщает JSX (HTML внтри js-кода) - это комопнента. Если возвращает другую компоненту - это HOC<br>
  Примеры:
  
  ```
    //Компонента, возвращает JSX
    let User = (props) => {
      return <div>
        <h1>[props.name]</h1>
      </div>
    }
    
    //Тоже компонента (похоже контейнерная), возвращает JSX (который отрисовывает другую компоненту)
    let UserContainer = (props) => {
      return <User example="text" />
    }
    
    //HOC, принимает комопоненту, возвращает другую компоненту (контейнерную)
    let HOComponent = (User) => {
      return UserContainer
    }    
  ```
  
  Если точнее, будет так:
  
  ```
    //HOC, принимает комопоненту, возвращает другую компоненту (контейнерную)
    let HOComponent = (Component) => {
      let WrapperContainer = (props) => {
        return <Component example="text" />
      }
      return WrapperContainer
    }    
  ```
     
  Connect из Redux - это тоже HOC. Ну, если быть точным - он возвращает HOC
  
  HOC часто называют с префиксом with - withRedirect, withAuth... В заивисмости от того, какую функциональность добавляет данный HOC.

  **Ссылки**
  - [Оф. документация - Компоненты высшего порядка](https://ru.reactjs.org/docs/higher-order-components.html)
  - [YouTube - IT Kamasutra 69](https://www.youtube.com/watch?v=7W4PD4BN3eY)
  - [YouTube - IT Kamasutra 70](https://www.youtube.com/watch?v=tf4E6tw8ZVw)
  
  <br></p></details>
  
  
  <details><summary><b>Советы по организации кода</b></summary><p>
    
  Компоненты обычно располагаются в папке src/components.  
    
  На каждый компонент обычно заводят отдельный файл.  
  
  Название файла обычно = названию компонента, также с большой буквы. Например: `src/components/Article.js`
  
  Каждый раз добавляя новую функциональность - думать чтоб вынести её в отдельный компонент.
    
  Каждый раз дублируя код - думать чтоб вынести её в отдельный компонент/функцию.  
     
  <br></p></details>

<br></p></details>

#
<details><summary><b>REACT - компоненты. Жизненный цикл</b></summary><p>
  
  ---
 
  Методы, которые React вызывает при разных событиях из жизни компонента (появление, удаление...)<br>
  Каждый классовый компонент имеет несколько «методов жизненного цикла».<br>
  Можно переопределить методы для запуска кода в определённое время в процессе работы приложения.<br>
  Единственный обязательный метод в подклассе React.Component — render(). Все остальные методы, описанные ниже, являются необязательными.<br>
  
  **Префикс в названии**
  - will 	 - вызываются прямо перед тем, как что-то происходит, 
  - did  	 - вызываются сразу после того, как что-то происходит.
  - should - должен
  
  <br>
  
  **1. Монтирование** - когда экземпляр компонента создаётся и монтируется в DOM
  
  <details><summary><b>constructor()</b> - конструктор, в котором происходит начальная инициализация компонента</summary><p>
  
  Если вы не инициализируете состояние и не привязываете методы, вам не нужно реализовывать конструктор для вашего компонента React.
  
  Конструктор компонента React вызывается до его монтирования. При реализации конструктора подкласса React.Component вы должны вызвать super(props) перед любым другим оператором. В противном случае this.props не будет определен в конструкторе, что может привести к ошибкам.
  
  Как правило, в React конструкторы используются для двух целей:
  - Инициализация локального состояния путем присвоения объекта this.state.
  - Привязка методов-обработчиквов событий к экземпляру.
  
  Вы не должны вызывать setState() в constructor(). Вместо этого, если вашему компоненту нужно использовать локальное состояние, присвойте начальное состояние this.state непосредственно в конструкторе
  
  <br></p></details>
    
    
  <details><summary>static getDerivedStateFromProps()</summary><p>
  
  [static getDerivedStateFromProps()](https://ru.react.js.org/docs/react-component.html#static-getderivedstatefromprops)
  
  <br></p></details>
  
  
  <details><summary><b>render()</b> - рендеринг компонента</summary><p>
  
  чистый, не пихать сюда ничего. Только для того, чтобы строить виртуальный DOM компонента
  
  <br></p></details>

  <details><summary><b>componentDidMount()</b> - после рендеринга компонента. Здесь можно выполнять запросы к удаленным ресурсам.</summary><p>

  - реагируем на появление компонента в реальном DOM. 
  - Например получить размеры, позиционирование, подписаться на изменение данных, повесить свои listener на DOM-элементы...
  - происходит один единственный раз - при отрисовке компоненты на странице. При обновлении - не вызывается.
  - Все сайд-эффекты делать в ComponentDidMount() Например, там вызываются запросы на сервак, AJAX-запросы, setTimeout и все манипуляции с DOOM

  <br></p></details>
  
  <br>
  
  **2. Обновление** - когда компонент перерисовывается. Может быть вызвано изменениями в state или props
 
   <details><summary>static getDerivedStateFromProps()</summary><p>
   
   [static getDerivedStateFromProps()](https://ru.reactjs.org/docs/react-component.html#static-getderivedstatefromprops)
   
   <br></p></details>
 
  <details><summary><b>shouldComponentUpdate()</b> - каждый раз при обновлении объекта props или state</summary><p>
  
  - позволяет оптимизировать приложение в ручном режиме, управляя тем, нужно ли перестраивать виртуальный DOM для этого компонента или нет?
  - т.е. позволяет оптимизировать перерисовку виртуального DOM - если в это компоненте ничего не поменялось, не перерисовываем 
  - Вызывается при изменении родителей, и при смене setState в самом компоненте.
  - Не забывать, про сравнение ссылочных типов. Не должно быть мутации данных
    - Каждый раз, когда меняются данные, должна создаваться новая ссылка.
      либо заменяем все мутабельные операции на аналогичные иммутабельные операции, 
      либо создаем новую ссылку и затем уже её мутируем.
    - Новая ссылка должна создаваться только тогда, когда меняются данные.
  - Предупреждает, что сейчас будем перестраивать виртуальный DOM этого компонента. 
  Можно отреагировать на изменения - загрузить текст для статьи, которая открывается и т.д.  Вызывается и при изменении родителей, и при смене setState  в самом компоненте.
  
  **Ссылки:**
  [YouTube - Оптимизация приложений, shouldComponentUpdate](https://www.youtube.com/watch?v=Jw1zocLDnnc)
  
  <br></p></details>
  
  
  <details><summary><b>render()</b></summary><p>
   
  - чистый, не пихать сюда ничего. 
  Только для того, чтобы строить виртуальный DOM компонента
  - Использовать его для обновления компонента. Можно, при создании компонента, наследовать его от компонента PureComponent - тогда сравниваются ВСЕ props (старые и новые) и ВСЕ элементы state (старые и новые).
  Т.е. не надо каждый раз объявлять «отслеживай ещё изменения этого параметра» — он будет следить по-умолчанию.
  Но, без необходимости лучше не использовать — могу вылезти сложные баги
  
  <br></p></details>
 
   
  <details><summary>getSnapshotBeforeUpdate()</summary><p>
  
  [getSnapshotBeforeUpdate()](https://ru.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate)
  
  <br></p></details>
  
    
  <details><summary><b>componentDidUpdate()</b> - сразу после обновления компонента (если shouldComponentUpdate возвращает true</summary><p>
  
  чаще всего нужен, если нас интересуют составляющие реального DOM (размер компонента, позиционирование...)
  
  <br></p></details>
  
  <br>
    
  **3 Демонтирование** - когда компонент удаляется из DOM
 
  <details><summary><b>componentWillUnmount()</b> - перед удалением компонента из DOM.</summary><p>
  
  предупреждает что компонент будет удалён. 
  
  Подчищаем подписки, проводим логику деструктуризации компонента
  
  Например, остановить и обнулить таймер
  
  <br></p></details>
  
  <br>


  **4 Обработка ошибок** - при возникновении ошибки
     
  <details><summary><b>componentDidCatch()</b></summary><p>
  
  Вызывается при ошибках:
  - ошибки во время отрисовки
  - ошибки в методе жизненного цикла
  - ошибки в конструкторе любого дочернего компонента.
  
  <br></p></details>
  
  <br>
  
  **Эти методы считаются устаревшими. Избегайте их:**
   <details><summary>1. componentWillMount() - непосредственно перед рендерингом компонента</summary><p>
   
   Часто используется для получения данных (отправка запроса за статьёй на сервер и т.д.)
   
   <br></p></details>
 
  <details><summary>2. componentWillReceiveProps() - при обновлении props, до монтирования новых</summary><p>
    
  При обновлении props, до монтирования новых.
    
    Здесь надо обновлять state компонента из приходящих props
    
    Тут приходят новые props.
    
    Вызывается до монтирования новых пропсов в компонент.
    
    Обычно в этой функции устанавливаются свойства компонента (в том числе из this.state), которые зависят от значений из пришедших в компонент props
    
    React передаёт новые props, которые можно сравнить с текущими. Вызывается только если поменялся кто-то из родителей и буду меняться какие-то props. 
    
    Два основных варианта использования:
    - поменялись важные данные и надо отреагировать. Например пришла новая статья и надо загрузить её с сервера
    - мы завязали состояние компонента на porps (не лучшая практика, но иногда оптимальная) - теперь надо следить за изменениями в props, и приводить state к нужному виду. Например, состояние статьи (свёрнута/развёрнута) приходят в компонент из другого компонента, через props. Тогда надо отслеживать -изменились ли эти props, и перерисовывать состояния статьи
            
  <br></p></details>
  <details><summary>2. componentWillUpdate() - перед обновлением компонента (если shouldComponentUpdate вернул true)</summary></details>
  
  <br>

  **I. Другие API** - каждый компонент также предоставляет некоторые другие API:
  - setState()
  - forceUpdate()
  
  **II. Свойства класса**
  - defaultProps
  - displayName
  
  **III. Свойства экземпляра**
  - props
  - state
  
  <br>
  
  **Ссылки**    
  - [Схема (en)](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
  - [Оф. документация - React.Component](https://reactjs.org/docs/react-component.html)
  - [https://metanit.com/web/react/2.6.php](https://metanit.com/web/react/2.6.php)
  - [https://learn-reactjs.ru/reference/react-component](https://learn-reactjs.ru/reference/react-component)

<br></p></details>

#
<details><summary><b>REACT - Context API</b></summary><p>
  
  ---  
  <details><summary><b>Что такое контекст и зачем он нужен?</b></summary><p>
  
  Объект, который создаётся у родителя и доступен всем детям.
  
  Контекст предоставляет способ делиться данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева.
  
  Может содержать некоторые очень глобальные данные - активный язык приложения (ru/en), активную тему оформления (ночь/день), store... Т.е. что-то, что редко меняется 
  
  Что попало туда пихать не надо, только очень глобальные вещи. 
  
  Контекст нужен чтобы не пробрасывать некоторые данные по длинной цепочке только для того, чтоб они пришли в компоненту нижнего уровня - эти данные помещаются в контекст а компонента нижнего уровня берёт их сразу оттуда, не из props. Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.
  
  Раньше был [старый синтаксис](https://ru.reactjs.org/docs/legacy-context.html) Context, его использовать не надо
  
  <br></p></details>
  
  <details><summary><b>Context API: createContext, Provider, Consumer</b></summary><p>

  - Функция React.createContext, которая создает объект Context
  - Provider (возвращается createContext) - устанавливает «шину» для прямой передачи данных, проходящую через дерево компонентов
  - Consumer (возвращается createContext) - впитывается в «шину» для извлечения данных

  <br></p></details>
  
  <details><summary><b>Provider</b></summary><p>
  
  Provider очень похож на Provider в React-Redux. Он принимает значение, которое может быть всем, чем хотите (это может быть даже store Redux… но это было бы глупо). Скорее всего, это объект, содержащий ваши данные и любые actions, которые вы хотите выполнить с данными.
  
  <br></p></details>
                                                                      
  <details><summary><b>Consumer</b></summary><p> 
  
  Consumer работает немного похоже как функция connect в React-Redux, подключаясь к данным, и сделав их доступными для компонента, который их использует.
  
  <br></p></details> 
  
  **Ссылки**
  - [Оф. документация - Контекст](https://ru.reactjs.org/docs/context.html)
  - [https://habr.com/ru/post/419449/](https://habr.com/ru/post/419449/)
  
<br></p></details>

#
<details><summary><b>REACT - Хуки</b></summary><p>
  
  ---
  
  <details><summary>Что такое Хук и зачем он нужен?</summary><p>
  
  Хук — функция, с помощью которой можно «подцепиться» к state и методам жизненного цикла React из функц. компонент. Не работает в  классах.
  
  Хуки — это способ использовать повторно логику состояния, а не само состояние.
  
  Каждое обращение к хуку обеспечивает совершенно изолированное состояние. Вы даже можете использовать один и тот же хук несколько раз в одном компоненте.
  
  React содержит несколько встроенных хуков, таких как useState. Можно создавать собственные хуки, чтобы повторно использовать их в других компонентах.
  
  Хуки следует вызывать только на верхнем уровне. Не вызывайте хуки внутри циклов, условий или вложенных функций.
  
  Хуки следует вызывать только из функциональных компонентов React. Не вызывайте хуки из обычных JavaScript-функций.<br> 
  Есть только одно исключение, откуда можно вызывать хуки — это ваши пользовательские хуки. 
  
  Поскольку хуки являются функциями, мы можем передавать информацию между ними.
  
  **Ссылки**
   - [Оф. документация](https://ru.reactjs.org/docs/hooks-intro.html)
   
  <br></p></details>
  
  
  <details><summary>Пользовательские хуки</summary><p>
  
  функция, имя которой начинается с «use», и которая может вызывать другие хуки.
  
  **Ссылки**
  - [Оф. документация](https://ru.reactjs.org/docs/hooks-custom.html)
  
  <br></p></details>
  
  
  <details><summary>Пример хука состояния (useState)</summary><p>

  ```
  import React, { useState } from 'react';

  function Example() {
    // Объявление новой переменной состояния «count»
    const [count, setCount] = useState(0);

    return (
      <div>
        <p>Вы кликнули {count} раз(а)</p>
        <button onClick={() => setCount(count + 1)}>
          Нажми на меня
        </button>
      </div>
    );
  }
  ```

  Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние. 
  Поэтому мы пишем const [count, setCount] = useState(). 
  Это похоже на this.state.count и this.setState в классах, с той лишь разницей, что сейчас мы принимаем их сразу в паре. 

  В классовой компоненте это выглядело бы так:
  ```
    class Example extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0
        };
      }

      render() {
        return (
          <div>
            <p>Вы кликнули {this.state.count} раз(а)</p>
            <button onClick={() => this.setState({ count: this.state.count + 1 })}>
              Нажми на меня
            </button>
          </div>
        );
      }
    }
  ```  
  Чтоб прочитать state из хука мы используем переменную, которую ранее объявили</summary>
  Например:
    <p>Вы кликнули {count} раз(а)</p>

  В классовой	компоненте это было бы так: 
    <p>Вы кликнули {this.state.count} раз(а)</p>

  Чтобы обновить state:</summary>
    <button onClick={() => setCount(count + 1)}>
      Нажми на меня
    </button>

  В классовой компоненте это было бы так:
    <button onClick={() => this.setState({ count: this.state.count + 1 })}>
      Нажми на меня
    </button>
    
  В отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а не осуществляет слияние.
    
  **Ссылки**
  - https://ru.reactjs.org/docs/hooks-state.html
  
  <br></p></details>
<br></p></details>

#
<details><summary><b>REACT - Роутинг</b></summary><p>
  
  ---  
  <details><summary>Что такое React-Router?</summary><p>
  
  React-Router - набор компонентов определяющих на основе текущего пути, какой компонент будет выводиться.
  - react-router - пакет с базовым набором функций
  - router-dom - пакет с набором функций для работы в браузере
  
  <br></p></details>
  
  <details><summary>BrowserRouter и HashRouter</summary><p>
  
  Для браузерных проектов есть BrowserRouter и HashRouter компоненты.
  - BrowserRouter — следует использовать когда вы обрабатываете на сервере динамические запросы. Если проект предполагает бекенд - бери BrowserRouter.
  - HashRouter - когда у вас статический веб сайт.
  
  Обычно предпочтительнее использовать BrowserRouter, но если ваш сайт расположен на статическом сервере(как github pages), то использовать HashRouter это хорошее решение проблемы.
  
  <br></p></details>
  
  <details><summary>Компонент Route</summary><p>
  
  <Route/> - компонент, строительный блок React Router'а.
  Если вам нужно рендерить элемент в зависимости от pathname URL'ов, то следует использовать компонент <Route/>
  
  <br></p></details>
  
  <details><summary>Как связаны Route и NavLink?</summary><p>
  
  Route и NavLink = два независимых элемента.
  
  Фактически, это обычные компоненты, написанные разработчиками, и подключаемые из билиотеки. В них передаются параметры и функции. ПРи наступлении условия X сделай то-=то (например, отрисуй компоненту такую-то) 
  - Route - меняет содержимое страницы, в зависимости от того, что введено в адресной строке. Следит за ней, и при изменениии - отрабатывает
  - NavLink - при клике меняет адрес в адресной строке
  
  <br></p></details>

  **Ссылки**
  - http://bogdanov-blog.ru/react-router-v4-notes/
  - https://habrahabr.ru/post/329996/
       
<br></p></details>

#
<details><summary><b>REACT - Статическая типзация</b></summary><p>
  
  ---
  <details><summary><b>Про статическую типизацию</b></summary><p>
  
  При статической типизации мне необязательно напоминать компилятору, что данная переменная, например, целое число, и всегда должно им оставаться. Эта информация хранится в программе, и даже если я, забывшись, попытаюсь изменить ее значение на недопустимое, ничего страшного не произойдет.
    
  Статическая типизация: C, C++, C#, Java, Pascal...
    
  Динамическая типизация: Perl, Ruby, JavaScript, Lisp, PHP, Python...
        
  Статические языки производительнее.
    
  Статические языки - с помощью тестирования типов легко проверить работоспособность кода еще до его выполнения. 
    
  Эффективность. Статическая типизация требует от программиста большей ответственности. Динамические языки, в свою очередь, могут поощрять некоторую раскованность, вырабатывая у разработчика привычку следовать дурным паттернам.
  
  В каждом случае если вы хотите использовать типы, то явно говорите инструменту, в каких файлах осуществлять проверку типов.</summary>
  - В случае TypeScript вы делаете, создавая файлы с расширением .ts вместо .js. 
  - В случае Flow вы указываете в начале кода комментарий @flow.
  
  - Динамический пример на JS
    var name = "Susan",
      age = 25,
      hasCode = true;
  
  - Статический пример на TypeScript
    let name: string = "Susan",
      age: number = 25,
      hasCode: boolean = true;
  
  <br></p></details>
  
  
  <details><summary><b>Type Script</b> - язык (Microsoft)</summary><p>
  
  язык разработанный Microsoft. Совместим с JS (расширяет его). Добавляет возможности статической типизации и ООП.
  
  представляет собой надмножество, которое компилируется в JavaScript — хотя по ощущениям TypeScript похож на новый язык со статической типизацией сам по себе. То есть очень похож на JavaScript и не сложен в освоении.
  
  есть аналогичное решение от Facebook - Flow.
  
  в Angular разработка ведётся на TypScript
  
  Динамический пример на JS
  ```
        var name = "Susan",
          age = 25,
          hasCode = true;
  ```
  
  Статический пример на TypeScript
  ```
        let name: string = "Susan",
          age: number = 25,
          hasCode: boolean = true;
   ```
       
   Надо явно сообщить React, в каких файлах осуществлять проверку типов - создаём файлы с расширением .ts вместо .js. **Уточнить:** кажется, это вообще отдельные от кода файлы с описанием типов. 
          
  </details>
  
  <details>
    <summary><b>Flow</b> - библиотека (Facebook)</summary>
      open source библиотека для статической проверки типов, которую разработала и выпустила Facebook. 
      Позволяет постепенно добавлять типы в ваш код JavaScript.
      Flow представляет собой инструмент статического анализа, который использует надмножество языка, позволяя добавлять аннотации типов к ко всему вашему коду и улавливать весь класс ошибок во время компиляции.
      
   Надо явно сообщить React, в каких файлах осуществлять проверку типов - указывать в начале кода комментарий @flow.
   
  </details>
  
  <details><summary><b>PropTypes</b> - библиотека React</summary><p>
    
  Очень простой - проверяет только props.
  
  - изначально был в составе React, потом вынесли в отдельную библиотеку
  - функциональность намного меньше и проще, чем у TS/Flow
  - проверяет только props
  - выдаёт предупреждения об ошибках типов во время запуска

  PropTypes может давать вам предупреждения во время выполнения, что может быть полезно для быстрого поиска неверных ответов, поступающих с сервера, и т.

  В существующих приложениях с большими объектами, это быстро приведет к большому количеству кода. Это проблема, так как в Реакте часто нужно передавать один и тот же объект множеству компонентов. Повторение этого процесса во множестве компонентов нарушает принцип DRY (Don’t Repeat Yourself). Самоповторы приводят к проблемам с поддержкой.

  Проблема с использованием PropTypes вместе с Flow заключается в том, что вы пишете много дубликатов кода. Оба определения в основном содержат ту же информацию, и когда тип данных изменяется, необходимо обновить оба определения.

  - propTypes - специальное свойство класса компонента (так было раньше?). Задают типы входных параметров для отрисовываемого компонента.
  
  
  В случае несовпадения (например вместо числа пришла строка) позволяют получить ошибку в react-dev-tools и отловить этот момент во время выполнения. 
  
  Это была встроенная возможность контроля типов для больших приложений, но с недавнего времени вынесена в отдельный пакет. 
  
  Для некоторых приложений, вы можете использовать расширения JavaScript такие как Flow или TypeScript осуществляя проверку типов всего вашего приложения. Но если вы не используете таковые — React предоставляет некоторые встроенные возможности проверки типов.
  
  Пример:
  ```
  class Greeting extends React.Component {
    render() {
      return (
        <h1>Hello, {this.props.name}</h1>
      );
    }
  }

  Greeting.propTypes = {
    name: React.PropTypes.string
  };
  ```

  В целях производительности, propTypes проверяются только в режиме разработки (development). Т.е. сам код остаётся, но не проверяется. Для удаления кода есть спец. модуль
  
  **Ссылки:**
  -[habr](https://habr.com/ru/post/319358/)
        
  <br></p></details>
  
  <details><summary><b>Различия PropTypes и Flow</b></summary>
    
  Flow - почти язык
  
  PropTypes - едва ли библиотека
  
  Кроме того, что и PropTypes и Flow  относятся к очень широкому полю проверки типов, между ними нет особого сходства.
  
  Flow представляет собой инструмент статического анализа, который использует надмножество языка, позволяя добавлять аннотации типов к ко всему вашему коду и улавливать весь класс ошибок во время компиляции.
  
  PropTypes - это базовая проверяльщик типов, который был частью React. Он не может проверять ничего, кроме типов props, передаваемого данному компоненту.
  
  Если вам нужен более гибкий метод проверки типов для всего проекта, то Flow/TypeScript являются подходящими. 
  
  Пока вы передаете только аннотированные типы в компоненты, вам не понадобятся PropTypes.
  
  Если вы просто хотите проверить типы props, не делайте излишнюю усложнение остальной части своей кодовой базы и идите с более простой опцией.
  
  
  - Flow - инструмент статического анализа 
  - PropTypes - инструмент проверки во время запуска. Теоретически может отловить ошибки, которые могут быть пропущены Flow
  
  <br></p></details>
  
  **Ссылки:**
  - https://ru.reactjs.org/docs/static-type-checking.html

<br></p></details>

#
<details><summary><b>REACT - JSX</b></summary><p>
  
  ---
  <details><summary>Что такое JSX?</summary><p>
  
  JavaScript XML (JSX) - расширение синтаксиса JavaScript, "синтаксический сахар" для JS. Позволяет использовать похожий на HTML синтаксис для описания структуры интерфейса.
        https://learn.javascript.ru/screencast/react#03-jsx
        При помощи Babel он компилируется в обычный JS. В JSX пишется и html-содержимое компонентов.
        Расширение .jsx использоватьтолько для компонент. Не использовать для редьюсеров и т.д.т
    
        - JSX - синтаксическое расширение JavaScript. 
          JSX производит React-элементы. 
          Можно работать с React на обычном JS, без JSX. 
          Babel компилирует JSX в вызовы React.createElement().
    
  <br></p></details>
    
    
  <details><summary>Зачем нужен JSX?</summary> 
  
  React учитывает тот факт, что логика отрисовки связана с другой логикой пользовательского интерфейса: как обрабатываются события, как изменяется состояние со временем и как данные подготавливаются для отображения.
        Вместо того, чтобы искусственно отделять технологии, помещая разметку и логику в отдельные файлы, React разделяет задачи , используя слабо связанные единицы, называемыми «компонентами», которые содержат и разметку, и логику. 
  
  </details>
    
    
  <details><summary>В JSX нельзя вывести два html-элемента рядом, вот так:</summary> 
        
        function Test() {
          return (
            <h1>Title</h1>
            <p>Text</p>
            <div></div>
          )
        }
    
        Надо так:
          function Test() {
            return (
              <div>
                <h1>Title</h1>
                <p>Text</p>
              </div>
            )
          }
    
        Или так:
          function Test() {
            return [
              <h1 key = 'a'>Title</h1>,
              <p  key = 'b'>Text</p>
            ]
          }
    
    
        - чтоб создать в JSX пустую корневую компоненту можно сделать так:
          return <>
            <ComponentOne />
            <ComponentTwo />
          </>
    
          Иначе - только через массив с уникальными ключами
  </details>
    
  <details><summary>В JSX обязательно надо закрывать открытый тэг. Но, можно использовать такой синтаксис <Article /></summary>  
    
  </details>
    
  <details><summary>В JSX есть соглашение - все кастомные (т.е. мной созданные) компоненты называются с большой буквы .</summary>  
        Пример: Aricle, MyComponent...
        Т.к. компонент = класс. 
        И при выводе их внутри других компонентов - тоже (<Aricle />, <MyComponent />, ...)
  
  </details>
    
  <details><summary>В JXS, если надо написать кусок на обычном JS, я помещаю его в фигурные скобки.</summary>  
        Например, создаю и вывожу переменную
          function Test() {
            const text = <p>Text</p>
            return (
              <div>
                <h1>Title</h1>
                {text}
              </div>
            )
          }
    
        Лучше не злоупотреблять выводом внутри JSX фигруных скобок с JS - тяжело разбираться. 
        Если нужны большие объёмы - выноси в переменные (см выше)
  </details>
    
  <details><summary>В JXS аттрибуты html пишут так:</summary> 
          function Test() {
            return (
              <div className="test" style={{color: 'red'}}>
                <h1>Title</h1>
              </div>
            )
          }
  </details>
    
  <details><summary>JSX предотвращает атаки, основанные на инъекции кода.</summary>  
        https://ru.reactjs.org/docs/introducing-jsx.html
        Данные, введённые пользователем, можно безопасно использовать в JSX. 
        По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. 
        Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
        Всё преобразуется в строчки, перед тем как быть отрендеренным. 
        Это помогает предотвращать атаки межсайтовым скриптингом (XSS).
  </details>
    
  <details><summary>Все атрибуты элементов React именуются с помощью camelCase.</summary>  
        CSS-class записываем как className
        tabindex = tabIndex
  </details>
    
  <details><summary>Внутри JSX разметки можно использовать только готовые выражения.</summary>  
        Нельзя, например, использовать конструкцию if/else (точно?)
        но можно заменить ее тернарным оператором.
  </details>

<br></p></details>

#
<details><summary><b>REACT - CSS</b></summary><p>

  ---

  <details>
    <summary>Если нужно добавить свой CSS - создаю для этого компонента отдельную папку (название = названию компонента), в ней файл компонента (index.js) и style.css</summary>
  </details>
  
  <details>
    <summary>CSS лучше писать по BEM-методологии - http://ru.bem.info/methodology</summary>
  </details>
  
  <details>
    <summary>Использовать css modules.</summary> 
  </details>
  
  <details>
    <summary>Ещё крутая штука - Styled Components. Читать</summary>
  </details>
  
<br></p></details>

#
<details><summary><b>REDUX</b></summary><p>

  ---
  <details><summary>Redux</summary><>
Библиотека для управления state, которая реализует Flux-архитектуру      
Её надо инсталлировать отдельно
      Позволяет создавать свой store командой, а не вручную
      В частности, уменьшает связность - позволяет передавать данные не по цепочке props,  а сразу в нужную компоненту
  </details>
  
  <details><summary>React-redux = отдельная библиотека, выступает как прослойка между React и Redux.</summary> 
      Позволяет работать с Redux не заморачиваясь кучей сложностей. 
      Инкапсулирует часть вещей, прячет от нас всякие детали связанные с контекстом, store, dispatch, subscribe...
  </details>
  
  <details><summary>State (анг. состояние) — специальный js-объект <внутри компонента>. Хранит данные, которые могут изменятся с течением времени. </summary>
  
    <div>
      https://ru.reactjs.org/docs/state-and-lifecycle.html
      Это инструмент, позволяющий обновлять пользовательский интерфейс, основываясь на событиях. 
      Задачи компоненты - отрисовывать какие-то данные. Эти данные всегда называются state (состояние приложения). 
      Узнать состояние компонента можно с помощью конструкции this.state. 
      Изменить состояние можно с помощью this.setState(), если передадим этой функции объект, представляющий новое состояние. 
    
    <div>
      - state-managment - управление данными
        Задумывая архитектуру нового приложения, первым делом всегда думать - как я собираюсь организовать state-managment (управление данными)? 
        Чаще всего выбор зависит от того, в чём больше опыта. 
        State (Business Logic Layer) важнее чем UI.
        Какие есть подходы к state-managment?
            - local state of class component - локальный state классовых компонент. Используется не всегда. Для простых, небольших задач, маленьких проектов.
            - Redux (одна из реализаций FLUX) - функциональное програмирование
            - MobX - ООП
            - и ещё много других
    </div>
    <div>
      - Не изменяйте state напрямую
        // Неправильно
        this.state.comment = 'Привет';
  
        Вместо этого используйте setState():
        // Правильно
        this.setState({comment: 'Привет'});
  
        Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.
    </div>
    <div>
      - Обновления state могут быть асинхронными
        React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.
  
        Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.
  
        Например, следующий код может не обновить счётчик:
  
        // Неправильно
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
  
        Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:
  
        // Правильно
        this.setState((state, props) => ({
          counter: state.counter + props.increment
        }));
    </div>
    <div>
      - Однонаправленный поток данных
        В иерархии компонентов, ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. 
        Также не важно, как был создан определённый компонент — с помощью функции или класса.
        Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.
        Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов:
  
          <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
  
        Своё состояние можно передать и другому пользовательскому компоненту:
  
          <FormattedDate date={this.state.date} />
  
        Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения:
  
          function FormattedDate(props) {
            return <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>;
          }
  
        Этот процесс называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.
  
        Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.
    </div>
  </details>
  
  <details><summary>Store (анг. хранилище) - ООП-объект, который управляет state (объект хранящий состояние приложения).</summary> 
      Там лежит: 
        - сам state
        - методы для работы с ним
      Создаётся при помощи метода(?) createStore(reducers)
  </details>
  
  <details><summary>Dispath (анг. отправка) - метод объекта store, через который вызываем все другие методы объекта Store (что изменить state, т.е. состояние приложения).</summary> 
      Мы вводим в наш объект store один единственный метод, через который будем вызывать все другие методы объекта.
      Он принимает некий объект action. Выглядит так: dispath(action). 
      У action обязательно должно быть текстовое свойство type='' - в нём передаётся название требуемого действия (т.е. метода). 
      Эти текстовые названия всегда пишутся заглавными.
      State всегда меняется через dispath(action)
  </details>
  
  <details><summary>Action - объект, который через метод dispath передаётся в наш объект store, и там производит некие действия с данными (state). 
      У action есть как минимум одно свойство, type. 
      По type dispath определяет, какие именно действия надо произвести со state (какую ветку действий выбрать)
  </details>
  
  <details><summary>Action Creator - функции, которые возвращают объект action. То, что передаётся в mapDispatchToProps</summary>
      Содержит action - type и список данных, которые может получать. 
      Пример:
        export const updateTaskStatus = (status, id) => ({
          type: UPDATE_TASK_STATUS,
          newStatus: status,
          taskId: id,
        });
  </details>
  
  <details><summary>Reducer (анг. уменьшатель) - чистая функция, принимает state и action. Та самая простынь, где много switch</summary>
      Применяет action к этому state (если нужно) и возвращает новый state (если не изменился - тот же). 
      Позволяет разделить метод dispath на отдельные куски, чтоб с ним было удобнее работать. 
      Обычно каждый reducer отвечает за какую-то ветку state - например этот работает с одной страницей, а тот с другой; или один работает с цитатами, а другой с пользователями. 
      Reducers - это отдельные функции, а не методы объекта store. Они лежат отдельно от store. Поэтому store (и его метод dispatch) не в курсе, какой action какому reducer нужен - мы отправляем любой входящий action всем имеющимся reducers. Для работы reducer ему кроме action нужен ещё и state. Но, мы не отправляем весь state целиком каждому reducer - нет, каждому мы отправляем только ту ветку, с которой он работает.
      Reducer - только преобразователь. Он не вызывает subscriber и другие callbacks.
      Если тип action неизвестен - выдаём изначальный state
  
      const task_tables_reducer = (state = initialState, action) => {
        switch(action.type) {
          case IS_PAGINATION: {
            return {...state};
          }
          default:
            return state;
        }
      }
  
    - connect(mapStateToProps, mapDispatchToProps) - API-функция предоставляемая пакетом react-redux. 
      Позволяет создавать контейнерные компоненты
      Пробрасывает в презентационную компоненту данные из store, в виде props. Благодаря mapStateToProps
      Подписывает презентационную компоненту на все изменения state, которые мы объявили в mapStateToProps
      Позволяет контейнерной компоненте изменять store, благодаря mapDispatchToProps
      Connect автоматически делает подключенные компоненты «чистыми», то есть они будут повторно рендериться только при изменении их props — тоесть, когда изменяется их срез состояния Redux. Это предотвращает ненужный ре-рендер и ускоряет работу приложения.
  
    - mapDispatchToProps - объект, содержащий набор actionCreators. 
      Используется в connect
      Позволяет контейнерной компоненте диспатчить изменения в store
  </details>
  
  <details><summary>Provider - компонента, оборачивается вокруг корневой компоненты (<App>). Позволяет передавать store всем потомкам - теперь у connect() есть доступ к store.</summary><p>
  
      - пакет react-redux предоставляет разработчику компонент <Provider>, который можно использоваться для оборачивания корневого компонента приложения. Он принимает свойство store. Предполагается, что оно представляет собой ссылку на хранилище Redux, которое планируется использовать в приложении. Свойство store передаётся, в соответствии с иерархией приложения, компонентам-контейнерам, с использованием механизма контекста React:
  
  <br></p></details>
  
  <details><summary>Compose</summary><p>
  
  Подход из функционального программирования
  Реализацию этой функции предоставляет, в частности, Redux
  
  Позволяет объединить несколько последовательных вызовов функций. Полезно в ситуации конвейера - мы передаём данные в функцию A, результат её работы передаётся в функцию B, результат работы B передаётся в C... и так далее
  
  compose(
    connect(mapStateToProps, mapDispatchToProps),
    withAuthRedirect
  )
  (component)
  
  Обрачивание идёт "снизу вверх" - вначале обернёт withAuthRedirect(), потом connect(mapStateToProps, mapDispatchToProps)()
  
  **Ссылки**
  - [YouTube - IT Kamasutra 70](https://www.youtube.com/watch?v=tf4E6tw8ZVw)
  
  <br></p></details>
  
<br></p></details>

#
<details><summary><b>REDUX & AJAX</b></summary>
  
  ---
  <details><summary>самый простой вариант - делаем запрос внутри actionCreator.</summary>  
      Например, при помощи fetch:
        const fetchDog = (dispatch) => {
          dispatch(requestDog());
          return fetch('https://dog.ceo/api/breeds/image/random')
            .then(res => res.json())
            .then(
              data => dispatch(requestDogSuccess(data)),
              err => dispatch(requestDogError())
            );
        };
      Это простой, но очень негибкий подход. 
      Ядро Redux это контейнер состояния (state container), который поддерживает только синхронные потоки данных.
      В случае асинхронного вызова, надо сначала дождаться ответа и затем (если не было ошибок) обновить состояние. А  если у приложения сложная логика?
      Для этого Redux использует промежуточные слои (middlewares) - код, который выполняется после отправки действия, но перед вызовом редюсера.
      Промежуточные слои могут соединяться в цепочку вызовов для различной обработки действия (action), но на выходе обязательно должен быть простой объект (действие)
  </details>
  
  <details><summary>middlewares - промежуточные слои Redux. Используются для реализации асинхронности в Redux</summary> 	
      - функция, которая запускается каждый раз при отправке action’а
      - Ядро Redux это контейнер состояния (state container), который поддерживает только синхронные потоки данных. 
      На каждое действие, в хранилище (store) посылается объект, описывающий что произошло, затем вызывается редюсер (reducer) и состояние (state) сразу обновляется.
      - Промежуточный слой это кусок кода, который выполняется после отправки действия, но перед вызовом редюсера.
      - Промежуточные слои могут соединяться в цепочку вызовов для различной обработки действия (action), но на выходе обязательно должен быть простой объект (действие)
      - Для асинхронных операций, Redux предлагает использовать redux-thunk промежуточный слой.
  
      Написание собственной middleware не так сложно, как может показаться, и позволяет использовать некоторые мощные средства.
      Например…
          Хотите посылать API-запрос каждый раз, когда имя action’a начинается с FETCH_? Вы можете сделать это с помощью middleware.
          Хотите централизованное место для логирования событий в вашем аналитическом ПО? Middleware — хорошее место для этого.
          Хотите предотвратить запуск action’a в определенный момент времени? Вы можете сделать это с помощью middleware, невидимого для остальной части вашего приложения.
          Хотите перехватить action, имеющий токен JWT, и автоматически сохранить его в localStorage? Да, middleware.
  
  </details>
  
  <details><summary>redux-thunk - библиотека, один из вариантов реализации middleware (промежуточный слой) для React-Redux</summary> 
      https://habr.com/ru/post/351168/
      https://monsterlessons.com/project/lessons/reduxjs-asinhronnye-eksheny-s-pomoshyu-redux-thunk
      https://tuhub.ru/posts/redux-i-thunk-vmeste-react-rukovodstvo-dlya-chajnikov
  
      - thunk = преобразователь (англ)
      - стандартный путь выполнения асинхронных операций в Redux.
      - вводит понятие функции-преобразователя, которая вызывается внутри dispatch и уже по завершении своей работы возвращает нормлаьный dispatch (вызовет необходимый метод для изменения store)
      - вызываем dispatch, как обычно. Но передаем в него не обьект, а функцию-1, которая возвращает функцию-2. 
        В возвращаемой функции-2 есть аргумент dispatch. 
        Теперь мы можем в этой функции-1 делать любые асинхронные операции и вызывать dispatch тогда, когда нам нужно.
      - Преимуществом использования redux-thunk является то, что компонент не знает, что выполняется асинхронное действие.
        Т.к. промежуточный слой автоматически передает функцию dispatch в функцию, которую возвращает генератор действий, то снаружи, для компонента, нет никакой разницы в вызове синхронных и асинхронных действий (и компонентам больше не нужно об этом беспокоиться)
  
      - thunk = функция, которая выполняет асинхронную операцию и на выходе диспатчит какие-то action в reducers. 
        Саму функцию thunk тоже можно задиспатчить 
        По сути, thunk = название функции, в которой происходит какая-то логика.
        Эта функция производит какие-то асинхронные действия и при этом умеет вызывать различные dispatch по результатам этих асинхронных действий. 
        Чтобы она могла вызывать метод dispatch, он должен прийти в неё - т.е. dispatch надо передать в параметрах этой функции при её вызове
        Функцию thunk запускает Redux. Мы её диспатчим, а Redux store её запустит и закинет в неё свой метод dispatch.
  
        А откуда функция thunk получит данные, которые должна обработать? Например, текст сообщения, которое она должна послать AJAX'ом на сервер? Передать эти данные как параметр функции мы не можем, т.к. вызывать её будет store. 
        Эти данные она возьмёт из замыкания. 
        Чтоб возникло замыкание, функцию thunk надо вернуть из некоей родительской функции (тогда thunk получит доступ к данным родительской функции).
        Используем родительскую функцию ThunkCreator: 
          - В ThunkCreator передаём данные (для передачи AJAX'ом на сервер, например), 
          - ThunkCreator вернёт нам thunk (уже с замыканием в котором есть нужные данные).
          - полученную функцию thunk мы диспатчим в Redux store 
          - Redux при вызове thunk передаст в неё метод dispatch (чтоб thunk могла по результатам своей работы что-то задиспатчить в store)
        Т.е. по факту, мы: 
          - диспатчим вызов ThunkCreator, в который передаём данные
          - ThunkCreator вызовет thunk (данные уже в нём благодаря замыканию), 
          - thunk выполнит AJAX-логику 
          - и по результатам вызовет какие-то dispatch, которые уйдут в reducers.
  
        Один момент: store не умеет принимать функции (он ждёт объект со свойством type, чтоб раскидать по reducers). 
        То есть, store не может принять thunk :(
        Поэтому, приходится использовать middleware (промежуточный слой) - он вклинивается между приёмником dispatch в store и моментом передачи диспатчей по reducers. 
        Мы должны при создании store немного его перенастроить, чтоб добавить middleware в цепочку. 
        Получается такая логика:
          - если на вход поступил обычный dispatch - он проходит middleware насквозь и уходит в reducers. 
          - но, если на входе пришла функция (thunk) - она обрабатывается middleware, и её результаты снова отправляются на вход Store.
          - если эти результаты = ещё один thunk, то процесс повторяется (да, thunk могут быть вложенными)
          - если эти результаты = dispatch, то он проходит middleware насквозь и уходит в reducers. 
        
  
        https://www.youtube.com/watch?v=eWdnjfRu9Io
  </details>
  
  <details><summary>redux saga - другая библиотека, для реализации middleware (промежуточный слой) React-Redux</summary> 
      - Для упрощения и улучшения сайд-эффектов в приложениях React-Redux. Прежде всего - асинхронные запросы (извлечение данных и т.д.) и нечистые вещи (доступ к кешу браузера и т.д.)
      - Их легче тестировать, на них легче реализовать сложную логику (задержки, параллельные задачи, отмена задач,)
      - Саги это дизайн паттерн, который пришел из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.
      - Работают на основе функций-генераторов
      - Если говорить в общем, мы имеем сагу чья работа это следить за отправленными действиями (dispatched actions). И ещё одна сага-рабочий
      - Сага-наблюдатель (watcher saga) является ещё одним неявным слоем. Дает больше гибкости для реализации сложной логики, но иногда лишняя для простых приложений.
      - Effects. Методы внутри саг(?) возвращают не dispatch action, а объекты с инструкциями для промежуточного слоя (middleware) —  отправить действие. Эти возвращаемые объекты называются Эффекты (Effects)
      
      - Есть альтернативы redux-saga, которые стоит попробовать. Две самых популярных это:
        - redux-observable (который базируется на RxJS) 
        - redux-logic (также базирующийся на RxJS наблюдателях, но дающий свободу писать вашу логику в других стилях).
  </details>
  
  <details><summary>axios - инструмент для отправки ajax-запросов, основанный на промисах, очень похожий на jQuery.</summary> 
      - Альтернативы: got, fetch, SuperAgent, jQuery
  </details>
  
  <details><summary>Вариант организации AJAX (IT-Kamasutra)</summary> 
      https://www.youtube.com/watch?v=c34P8-9YVMQ&list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8&index=51
  
      для работы с серверным API & AJAX - используем axios  
      Изначально у нас в стэйте нет данных (например, списка задач) - мы должны получить их с сервера
      Берём reducer, в котором эти данные выводятся и соответствующий action
      Создаём новый action = setTasks //получить-установить задачу
      В reducer пишем реакцию на этот action - добавить в state данные из объекта, который приходит с этим action
      В контейнерной компоненте, в функции mapStateToProps добавляем в state компоненты задачи из общего state 
      В контейнерной компоненте, в функции mapDispatchToProps создаём callback для вызова этого action. При вызове этого action - он добавит задачи в state 
      Сам факт захода пользователя на страницу со списком задач = действие (т.е. диспатч), которое вызывает этот action. 
  </details>

<br></p></details>

#
<details><summary><b>AJAX, JSON, CORS и т.д.</b></summary><p>
  
  ---
  <details><summary>Порт — это номер, который, выдаёт операционная система каждой программе, которая хочет отослать данные в сеть</summary>
  </details>
  
  <details><summary>TCP/IP - сетевая модель передачи данных, представленных в цифровом виде.</summary>
      T.е. теоретическое описание принципов работы набора сетевых протоколов, взаимодействующих друг с другом. 
      
      В модели предполагается прохождение информации через четыре уровня, каждый из которых описывается правилом (протоколом передачи). Наборы правил, решающих задачу по передаче данных, составляют стек протоколов передачи данных, на которых базируется Интернет[1][2]. 
  
      Название TCP/IP происходит из двух важнейших протоколов семейства — Transmission Control Protocol (TCP) и Internet Protocol (IP), которые были первыми разработаны и описаны в данном стандарте. 
  
  
      В протоколе Ethernet находятся номер сетевого адаптера отправителя (MAC-адрес), номер сетевого адаптера получателя, тип передаваемых данных и непосредственно передаваемые данные. Порция информации, составленная в соответствии с протоколом Ethernet, называется кадром. Считается, что сетевых адаптеров с одинаковым номером не существует. Сетевое оборудование извлекает передаваемые данные из кадра (аппаратно или программно), и производит дальнейшую обработку.
  
      Как правило, извлечённые данные в свою очередь сформированы в соответствии с протоколом IP и имеют другой вид идентификационной информации — ip адрес получателя (число размером в 4 байта), ip адрес отправителя и данные. А так же много другой необходимой служебной информации. Данные, сформированные в соответствии с IP протоколом, называются пакетами.
  
      Далее извлекаются данные из пакета. Но и эти данные, как правило, ещё не являются изначально отправляемыми данными. Этот кусок информации тоже составлен в соответствии определённому протоколу. Наиболее широко используется TCP протокол. В нём содержится такая идентификационная информация, как порт отправителя (число размером в два байта) и порт источника, а так же данные и служебная информация. Извлечённые данные из TCP, как правило, и есть те данные, которые программа, работающая на компьютере В, отправляла «программе-приёмнику» на компьютере A.
  
      Вложенность протоколов (в данном случае TCP поверх IP поверх Ethernet) называется стеком протоколов.
  
      Фактически TCP/IP не один протокол, а несколько. Именно поэтому вы часто слышите, как его называют набором, или комплектом протоколов, среди которых TCP и IP - два основных. 
  
      https://habr.com/ru/post/326574/
      https://ru.wikipedia.org/wiki/TCP/IP
  </details>
  
  <details><summary>HTTP - протокол передачи данных</summary>
      HyperText Transfer Protocol, «протокол передачи гипертекста»
  
      Протокол прикладного уровня (верхний 7-й уровень модел OSI) предназначенный для передачи произвольных данных при клиент-серверном взаимодействии.
  
      предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.
  
      HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как SOAP, XML-RPC и WebDAV. В таком случае говорят, что протокол HTTP используется как «транспорт».
  
      API многих программных продуктов также подразумевает использование HTTP для передачи данных — сами данные при этом могут иметь любой формат, например, XML или JSON.
  
      Как правило, передача данных по протоколу HTTP осуществляется через TCP/IP-соединения.
  </details>
  
  <details><summary>HTTPS - распространённое расширение HTTP, которое реализует упаковку передаваемых данных в криптографический протокол SSL или TLS.</summary>
      
      Методы HTTP-протокола:
        Метод — это указание операции над ресурсом.
          - GET — получение данных с ресурса. Не имеет тела, информацию можно передать только через querystring. Кэшируется.
          - HEAD — как GET но не возвращает данных. Используют для проверки существования сайта, получения метаданных. Кэшируется.
          - POST — отправка данных к ресурсу. Не кэшируется.
          - PUT — замещение данных ресурса. Не кэшируется.
          - DELETE — удаление данных ресурса. Не кэшируется.
          - OPTIONS — предварительный запрос к серверу при кросс-доменном запросе. Не кэшируется (???).
  
      https://habr.com/ru/post/215117/
  </details>
  
  <details><summary>JSON (Javascript Object Notation) - формат данных, который используется для представления объектов в виде строки.</summary>
      Если нужно с сервера взять объект с данными и передать его клиенту, то в качестве промежуточного формата – для передачи по сети, почти всегда используют именно его.
  
      Данные в формате JSON (RFC 4627) представляют собой:
          - JS-объекты { ... } или
          - Массивы    [ ... ] или
          - Значения одного из типов:
              - строки в двойных кавычках,
              - число,
              - логическое значение true/false,
              - null.
  
      https://learn.javascript.ru/json
  </details>
  
  <details><summary>AJAX - технология отправки запросов к серверу из клиентского кода JavaScript без перезагрузки страницы.</summary>
        https://learn.javascript.ru/ajax
        https://habr.com/ru/post/14246/
  
        Расшифровывается как Asynchronous JavaScript And XML. 
        Сейчас вместо чаще XML используют формат JSON.
        Слать AJAX-запросы к серверам с другим доменом запрещено на уровне браузера. Ajax не кроссдоменный, но подходит много для каких задач.
        Асинхронный
        Браузер предоставляет для AJAX специальный API: конструктор XMLHttpRequest
        AJAX работает через XMLHttpRequest (XMLHTTP, XHR), т.е. через запросы HTTP/HTTPS 
        Т.е. асинхронный обмен данными (JSON/XML/TXT) через HTTP/HTTPS запросы
  
        При использовании AJAX:
          - Пользователь заходит на веб-страницу и нажимает на какой-нибудь её элемент.
          - Скрипт (на языке JavaScript) определяет, какая информация необходима для обновления страницы.
          - Браузер отправляет соответствующий запрос на сервер.
          - Сервер возвращает только ту часть документа, на которую пришёл запрос.
          - Скрипт вносит изменения с учётом полученной информации (без полной перезагрузки страницы).
  
        AJAX использует два метода работы с веб-страницей: 
          - изменение Web-страницы без перезагрузки, используя DHTML (совокупность технологий CSS, DOM и JavaScript)
          - динамическое обращение к серверу. Может осуществляться несколькими способами, в частности, XMLHttpRequest, и использование техники скрытого фрейма.
  
      Алгоритм запроса к серверу выглядит так:
          - Проверка существования на странице объекта XMLHttpRequest. Создание данного объекта для каждого типа браузера — уникальный процесс.
          - Инициализация соединения с сервером.
          - Посылка запроса серверу (GET или POST)
          - Обработка полученных данных.
  
        От сервера можно получить данные нескольких видов:
          - Обычный текст
          - XML
          - JSON
  
        Альтернативы AJAX:
          - Java-апплеты, позднее технология JavaFX;
          - Технология Silverlight корпорации Microsoft;
          - Протокол WebSocket.
  </details>
  
  <details><summary>JSONP (JSON with Padding, JSON с набивкой) - протокол. Дополнение к формату JSON. Способ запросить данные с сервера, находящегося в другом домене.</summary>
      Не имеет отношения к AJAX
      Устаревший но хитрый способ двунаправленного кроссдоменного взаимодействия, основанный на загрузке скрипта с другого домена.
      В частности, с помощью протокла JSONP можно организовать некоторые разновидности технологии COMET. 
      Насколько я понимаю, работает также с использование XMLHttpRequest, т.е. поверх HTTP/HTTPS
  
      Согласно политике ограничения домена, веб-страница, расположенная на сервере server1.example.com, не может связаться с сервером, отличным от server1.example.com. Эта операция запрещена в большинстве браузеров.
  
      Идея основана на лазейке в стандартах: загружать скрипты с других доменов не запрещено!
  
      <!--
      В основу технологии JSONP положен тот факт, что политика безопасности браузера не запрещает использовать HTML-элемент <script type="text/javascript" src="…"/> для обращения к серверам, отличным от сервера, с которого произошла загрузка страницы. Используя открытую политику для элементов <script>, некоторые страницы используют их, чтобы загружать JavaScript-код, оперирующий динамически создаваемыми JSON-данными из других источников. 
  -->
      Запросы для JSONP получают не JSON, а произвольный JavaScript-код. Они обрабатываются интерпретатором JavaScript, а не парсером JSON.
  
      Существуют серьезные риски, связанные с безопасностью при использовании JSONP, в большинстве ситуаций использование CORS является лучшим выбором.
  
      JSONP кроссдоменный, но подходит только для случаев, когда надо кроссдоменно передать JSON.
  
      Набивка (префикс) 
        Набивка обычно является именем функции обратного вызова, определённой внутри контекста выполнения в браузере. Кроме имени функции префикс может означать имя переменной, оператор if, или любой другой оператор JavaScript. Ответ на JSONP-запрос (строго говоря — запрос, соответствующий паттерну JSONP) не является объектом JSON и не расценивается браузером, как таковой. «Начинка» может быть любым выражением на JavaScript, и вовсе не требует, чтобы внутри обязательно был JSON. Но обычно это фрагмент JavaScript, применяющий вызов функции к неким JSON-данным.
  
        Другими словами, типичное применение JSONP предоставляет междоменный доступ к существующему JSON API путём оборачивания начинки JSON в вызов функции.
  
      Недостатки
        - Прежде всего, это лазейка, костыль. Разработчики стандартов просто не были настолько хитры, чтобы предугадать динамическое взаимодействие на уровне скриптов.
  
        - Безопасность. Подгрузка скриптов ни разу не безопасней, чем Аякс. Целое семейство вирусов занимается тем, что добавляет на страницу браузера скрипты для отрисовки баннеров порно и казино. Когда вы подключаетесь к интернету через мобильных операторов, обсосы вставляют в HTML-трафик скрипты для отрисовки виджетов (если соединение не HTTPS)
  
        - Только GET. JSONP работает только методом GET, что сводит на нет возможности REST-интерфейса. Для REST-сервисов приходится писать прокладки-прокси, т.е. множить костыли. Неустранимое ограничение — позволяет только получение данных GET методом, то есть отправка данных через POST метод остается недоступной. 
  
        - Нельзя отслеживать. Добавив скрипт на страницу, в дальнейшем вы не можете отследить его судьбу. Если у Аякс-запроса есть специальные коллбеки для основных событий (начало, удачное завершение, таймаут, неудачное завершение), то у скрипта ничего такого нет. Загрузился ли он? Ответил ли сервер? Была ли ошибка? Никто не знает.
  
      Каковы проблемы JSONP?
          - Это вне стандартов.
          - Это небезопасно.
          - Если запрос провалился, то ничего мы никогда не узнаем, не обработаем ошибку правильно, не можем отследить судьбу запроса.
          - Мы работаем только с GET — никаких модных REST API.
          - И в общем, так делать не надо в 2017 году.
  
      Приложениям на js нужен надежный способ забирать данные с серверов. Чтобы это была законно, а не по-воровски в обход протоколов и стандартов. Таким способом стал CORS – Cross-Origin Resource Sharing, кросс-доменные запросы.
  
      https://ru.wikipedia.org/wiki/JSONP
      https://grishaev.me/cors/
  </details>
  
  <details><summary>JSONPP (англ. parameterized JSON with padding — «параметризованный JSON с подкладкой») — развитие идеи JSONP</summary>
      развитие идеи JSONP
      включает в себя URL источника, имя функции, которая будет обрабатывать JSON данные, строка для eval после получения данных и строка для eval после окончания обработки данных
  </details>
  
  <details><summary>CORS - кросс-доменные запросы. Разрешаем кросс-доменный AJAX (если сервер согласен его принять)</summary>
      Cross-origin resource sharing (англ. — «совместное использование ресурсов между разными источниками») 
      Технология современных браузеров, которая позволяет предоставить веб-странице доступ к ресурсам другого домена. Современный стандарт кроссдоменных запросов
      Слать AJAX-запросы к серверам с другим доменом запрещено на уровне браузера
      Фактически - расширение поверх AJAX
  
      Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. 
      Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
  
      Здесь: 
        - клиент шлет Аякс-запрос к чужому серверу. 
        - браузер добавляет в запрос особые заголовки с информацией о том, что запрос с другого домена. 
        - на их основании сервер решает, как обрабатывать такой запрос, и добавляет особые заголовки в ответ
  
      Браузер добавит заголовок Origin с адресом страницы, откуда инициирован запрос. Подделать заголовок скриптом не удастся
  
      Т.е. по факту я в своём приложении создаю AJAX запрос с опр. набором параметров (заголовки и т.д.), и если сервер поддерживает CORS - он пришлёт ответ
  
      Простые и сложные CORS-запросы
        - Сложные идут в два этапа (preflight запрос и собственно запрос). Сначала браузер делает запрос по тому же урлу, но методом OPTIONS. Сервер должен ответить: какими другими методами и дополнительными заголовками (помимо стандартных) можно обращаться к этому урлу. И только получив разрешение, браузер сделает запрос на основной урл.
        - Запрашиваешь JSON - автоматически должен использовать сложный запрос
  
      Поддержка браузерами
          - Firefox 3.5 и выше
          - Google Chrome 3 и выше
          - Opera 12.00
          - Safari 4 и выше
          - Internet Explorer 
            8      - частичная поддержка через XDomainRequest объект. 
            9      - частичная поддержка через XDomainRequest объект. 
            10 	   - встроенная поддержка
            10,11  - не поддерживают CORS для интернациональных доменных имен (IDN), содержащих нелатинские символы.
  
  
      Технология CORS может быть использована как более современная и надёжная альтернатива JSONP, так как позволяет использовать все преимущества XMLHttpRequest, и не имеет риска инъекции, как JSONP. С другой стороны, технология CORS поддерживается только современными браузерами, а JSONP работает и в старых тоже. 
  
      Механизм CORS поддерживает кросс-доменные запросы и передачу данных между браузером и web-серверами по защищенному соединению. 
      Современные браузеры используют CORS в API-контейнерах, таких как XMLHttpRequest или Fetch, чтобы снизить риски, присущие запросам с других источников.
  
      https://grishaev.me/cors/
      https://ru.wikipedia.org/wiki/Cross-origin_resource_sharing
      https://developer.mozilla.org/ru/docs/Web/HTTP/CORS
  </details>
  
  <details><summary>- COMET – общий термин, описывающий различные техники получения данных по инициативе сервера.</summary>
      Методика отправки данных по инициативе сервера, разработанная поверх AJAX.
      
      Можно сказать, что AJAX – это «отправил запрос – получил результат», а COMET – это «непрерывный канал, по которому приходят данные».
      COMET можно реализовать по протоколу JSONP. Можно и иначе 
      COMET - методика отправки данных по инициативе сервера, разработанная поверх AJAX.
  
      Примеры COMET-приложений:
          - Чат – человек сидит и смотрит, что пишут другие. Новые сообщения приходят «сами по себе», не надо жать кнопку для обновления окна.
          - Аукцион – человек смотрит на экран и видит, как обновляется текущая ставка за товар.
          - Интерфейс редактирования – когда один редактор начинает изменять документ, другие видят информацию об этом. Совместное редактирование.
  
      Какие API предоставляет браузер для взаимодействия COMET?
        - SSE (server-side events) API — события посылаемые сервером — однонаправленное HTTP-подключение к серверу. Поддерживают короткие запросы, длинные запросы, потоковое подключение к серверу.
        - Web Sockets API — двунаправленное взаимодействие с сервером. Работает по собственному протоколу.
  
        Страница не просто разово или циклично запрашивает контент с сервера, а создает с сервером постоянное HTTP-соединение и ждет от него передачи данных. Это позволяет пользователям веб-приложения более оперативно получать все возникающие на сервере события (пример - мгновенное уведомление о новом сообщении в социальных сетях). 
        В идеальном варианте для этого на сервере разворачивается специальное программное обеспечение, сам сервер особым образом конфигурируется, а на клиентской части используются специальные библиотеки для обмена данными. Это если рассматривать использование COMET в контексте больших и серьезных проектов. Для рядового сайта, размещенного на обычном хостинге с ограничением времени исполнения скрипта, можно сделать облегченный аналог COMET.
  
        - polling
          Использование периодических запросов к серверу через AJAX. Например, скрипт из браузера каждые 5 секунд отправляет запрос на серверный скрипт и запрашивает количество новых непрочитанных сообщений. 
          Можно дополнительно снизить нагрузку на сервер путем снижения частоты отсылаемых запросов, но это опять же пойдет в ущерб актуальности данных и в разрез с условием задачи о мгновенном информировании пользователя о письме.
  
        - long polling (это вариант реализации COMET) 
          Есть несколько вариантов реализации, но, к сожалению, практически все они завязаны на конкретном браузере и ведут себя по-своему. 
          Единственным кроссбраузерным и гарантированно работающим решением является так называемая "очередь длинных запросов", или "long polling". 
  
          Сначала браузер отправляет AJAX-запрос на сервер и ожидает ответа. Соединение остается открытым до тех пор, пока на сервере не наступит ожидаемое событие (или, как в нашем случае, пока серверный скрипт не отвалится по таймауту). Сразу после наступления события данные отправляются в браузер и соединение закрывается. Браузер после получения данных сразу же открывает новое соединение и все повторяется. 
  
          Это очень похоже на предыдущий способ "polling", но данные с сервера передаются с максимально возможной актуальностью. Если за время ожидания никаких событий на сервере не случилось, интервал между "долгими" запросами будет гораздо больше, чем при долбежке сервера периодическими опросами. Поэтому еще более минимизируются расходы на передачу заголовков запросов, тем самым еще больше снижается нагрузка на сервер.
  </details>
  
  <details><summary>WebSocket - протокол для пересылки любых данных, на любой домен, безопасно и почти без лишнего сетевого трафика. Замена AJAX.</summary>
      Один из API браузера, который он предоставляет чтоб реализовать COMET. 
      Альтернатива - SSE (server-side events) API.
      
      WebSocket - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени. 
      Предназначен для решения любых задач и снятия ограничений обмена данными между браузером и сервером.
      независимый протокол, основанный на протоколе TCP
      Не стоит использовать веб-сокеты в REST API, поскольку вам хватит таких HTTP-запросов, как GET, POST, DELETE и PUT.
      В отличие от CORS работает вообще без AJAX, отдельный протокол, даже на HTTP
  
      Протокол WebSocket работает над TCP& также как и HTTP. Т.е. на том же уровне, что и HTTP, заменяет его, а не "поверх него"
      AJAX работает на HTTP
      Это означает, что при соединении браузер отправляет по HTTP специальные заголовки, спрашивая: «поддерживает ли сервер WebSocket?».
      Если сервер в ответных заголовках отвечает «да, поддерживаю», то дальше HTTP прекращается и общение идёт на специальном протоколе WebSocket, который уже не имеет с HTTP ничего общего.
  
      Соединение WebSocket можно открывать как WS:// или как WSS://. Протокол WSS представляет собой WebSocket над HTTPS.
      Кроме большей безопасности, у WSS есть важное преимущество перед обычным WS – большая вероятность соединения.
      Дело в том, что HTTPS шифрует трафик от клиента к серверу, а HTTP – нет.
      Если между клиентом и сервером есть прокси, то в случае с HTTP все WebSocket-заголовки и данные передаются через него. Прокси имеет к ним доступ, ведь они никак не шифруются, и может расценить происходящее как нарушение протокола HTTP, обрезать заголовки или оборвать передачу.
      А в случае с WSS весь трафик сразу кодируется и через прокси проходит уже в закодированном виде. Поэтому заголовки гарантированно пройдут, и общая вероятность соединения через WSS выше, чем через WS.
  
      WebSocket поддерживается в следующих браузерах:
          Google Chrome (начиная с версии 4.0.249.0);
          Apple Safari (начиная с версии 5.0.7533.16);
          Mozilla Firefox (начиная с версии 4);
          Opera (начиная с версии 10.70 9067);
          Internet Explorer (начиная с версии 10);
  
          Проверить поддержку браузером WebSocket можно, пройдя по ссылке: http://caniuse.com/#feat=websockets. 
  
        Это сдвиг парадигмы HTTP. Изначально синхронный протокол, построенный по модели «запрос — ответ», становится полностью асинхронным и симметричным. Теперь уже нет клиента и сервера с фиксированными ролями, а есть два равноправных участника обмена данными. Каждый работает сам по себе, и когда надо отправляет данные другому. Отправил — и пошел дальше, ничего ждать не надо. Вторая сторона ответит, когда захочет — может не сразу, а может и вообще не ответит. Протокол дает полную свободу в обмене данными, вам решать как это использовать.
  
        Как только ваша страница решила, что она хочет открыть веб сокет на сервер, она создает специальный javascript-объект WebSocket  и навешивает на новый объект три колл-бека:
          - первый вызовется, когда соединение будет установлено:
          - второй - когда соединено закроется
          - третий - каждый раз, когда браузер получает какие-то данные через веб-сокет
        Браузер подключается по протоколу TCP на 80 порт сервера и дает немного необычный GET-запрос
        Если сервер поддерживает ВебСокеты, то он отвечает опр. образом
        Если браузер это устраивает, то он просто оставляет TCP-соединение открытым. Все — «рукопожатие» совершено, канал обмена данными готов.
        Как только одна сторона хочет передать другой какую-то информацию, она отправляет дата-фрей. Это просто строка текста — последовательность байт. Никаких заголовков, метаданных! Что именно отправлять, разработчики полностью оставили на ваше усмотрение: хотите XML, хотите JSON, да хоть стихи Пушкина.
        Каждый раз, когда браузер будет получать такое сообщение, он будет «дергать» ваш колл-бек onmessage. 
  
        Легко понять, что КПД такого протокола стремится к 95%. Это не классический AJAX-запрос, где на каждую фитюльку приходится пересылать несколько килобайт заголовков. Разница будет особенно заметна если делать частый обмен небольшими блоками данных. Скорость обработки так же стремится к скорости чистого TCP-сокета — ведь все уже готово — соединение открыто — всего лишь байты переслать.
  
        в качестве единственной разрешенной кодировки выбрана UTF-8
  
        А картинку можно отправить? Да. С помощью WebSockets так же можно передавать и бинарные данные. Для них используется другой дата-фрейм опр. вида
  
      Скорость и эффективность
        Высокую скорость и эффективность передачи обеспечивает малый размер передаваемых данных, который иногда даже будет помещаться в один TCP-пакет — здесь, конечно, же все зависит от вашей бизнес-логики. 
        Так же учтите, что соединение уже готово — не надо тратить время и трафик на его установление, хендшейки, переговоры.
  
      Стандартность
        Самим своим выходом WebSockets отправит на свалку истории Comet и все приблуды накрученные поверх него — Bayuex, LongPolling, MultiPart и так далее. Это все полезные технологии, но по большей части, они работают на хаках, а не стандартах. Отсюда периодески возникают проблемы
  
        Время жизни канала
        В отличие от HTTP веб-сокеты не имеют ограничений на время жизни в неактивном состоянии. Это значит, что больше не надо периодически рефрешить соединение, т.к. его не вправе «прихлопывать» всякие прокси. Значит, соединение может висеть в неактивном виде и не требовать ресурсов. Конечно, можно возразить, что на сервере будут забиваться TCP-сокеты. Для этого достаточно использовать хороший мультиплексор, и нормальный сервер легко потянет до миллиона открытых коннектов.
  
      Комплексные веб-приложения
        Как известно в HTTP предусмотрено ограничение на число одновременных октрытых сессий к одному серверу. Из-за этого если у вас много различных асинхронных блоков на странице, то вам приходилось делать не только серверный, но и клиентский мультиплексор — именно отсюда идет Bayeux Protocol.
        К счастью, это ограничение не распространяется на веб-сокеты. Открываете столько, сколько вам нужно. А сколько использовать — одно (и через него все мультиплексировать) или же наоборот — на каждый блок свое соединение — решать вам. Исходите из удобства разработки, нагрузки на сервер и клиент.
  
      Кросс-доменные приложения
        И еще один «камень в ботинке» AJAX-разработчика — проблемы с кросс-доменными приложениями. Да, и для них тоже придумана масса хаков. Помашем им ручкой и смахнем скупую слезу. WebSockets не имеет таких ограничений. Ограничения вводятся не по принципу «из-того-же-источника», а из «разрешенного-источника», и определяются не на клиенте, а на сервере. Думаю, внимательные уже заметили новый заголовок Origin. Через него передается информация откуда хотят подключиться к вашему websocket-у. Если этот адрес вас не устраивает, то вы отказываете в соединение.
        
  
      https://ru.wikipedia.org/wiki/WebSocket
      https://learn.javascript.ru/websockets
      https://blog.securityevaluators.com/websockets-not-bound-by-cors-does-this-mean-2e7819374acc
  </details>
  
  <details><summary>SSE API (server-side events) - события посылаемые сервером, т.е. однонаправленное HTTP-подключение к серверу.</summary>
      Ещё один вариант API, который предоставляет браузер для взаимодействия COMET. 
      Альтернатива WebSocket
  </details>
  
  <details><summary>XMLHttpRequest (XHR) - объект, который дает возможность браузеру из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.</summary>
      https://learn.javascript.ru/ajax-xmlhttprequest
      - Все современные браузеры (IE7+, Firefox, Chrome, Safari и Opera) имеют встроенный объект XMLHttpRequest.
      - Может работать с синхронными и асинхронными запросами
      - Как правило, XMLHttpRequest используют для загрузки данных.
  </details>
  
  <details><summary>Метод fetch - встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest.</summary>
      https://learn.javascript.ru/fetch
      Большинство браузеров уже поддерживает fetch – новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. 
      Он гораздо мощнее, чем httpGet. 
      Этот метод использует промисы. 
      Возвращает промис, который, когда получен ответ, выполняет коллбэки с объектом Response или с ошибкой, если запрос не удался.
  </details>
  
  <details><summary>DHTML (англ. Dynamic HTML) - совокупность технологий CSS, DOM и JavaScript</summary>
  </details>
  
  **Ссылки**
  - [Сети в вопросах и ответах. HTTP-протокол. AJAX. JSONP. CORS.COMET](https://medium.com/@olgakozlova/%D1%81%D0%B5%D1%82%D0%B8-%D0%B2-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%B0%D1%85-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0%D1%85-http-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB-ajax-jsonp-cors-comet-53c60319a5a7)
  - [Основы TCP/IP для будущих дилетантов](https://habr.com/ru/post/326574/)
  
<br></p></details>

#
<details><summary><b>Чистые функции</b></summary><p>
  
  ---
  
  - Чистая функция:
     - идемпотента 	    - при повторении операции даст тот же эффект
     - детерминирована   - для одних и тех же данных всегда выдаёт тот же результат
     - иммутабельна      - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.
     - без сайд-эффектов - побочных эффектов 
       Например: какой-то внешний объект изменился, и при тех же входящих данных мы получили новый результат
  
      Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.

    
    Пример чистой функции -  не меняет свои входные данные и предсказуемо возвращает один и тот же результат для одинаковых аргументов:
    ```
      function sum(a, b) {
        return a + b;
      }
    ```    
      
    Пример нечистой функции — записывает данные в свои же аргументы:
    ```
    function withdraw(account, amount) {
        account.total -= amount;
      }
    ```
    
  <details>
    <summary>Инкапсуляция = сокрытие лишних деталей</summary>
  </details>
  
  <details>
    <summary>Интерфейс - то как мы взаимодействуем с чем-то</summary>
        - интерфейс объекта - какие свойства и методы у него есть
        - интерфейс функции - её имя, какие параметры мы в неё передаём, какой ответ получаем...
  </details>
  
  <details>
    <summary>Идемпотентность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.</summary>
  </details>
  
  <details>
    <summary>Детерминированность - для одних и тех же исходных алгоритм выдаёт тот же результат.</summary>
      Результат однозначно определяется исходными данными.
  </details>
  
  <details>
    <summary>Иммутабельность - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.</summary>
  </details>

<br></p></details>

#
<details><summary><b>ООП</b></summary><p>
  
  ---
  
**Объе́ктно-ориенти́рованное программи́рование (ООП)** — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

**Базовые понятия**
- **Класс** - абстрактное описание автомобиля. Чертёж
- **Объект** - конкретная реализация автомобиля, данная машина
- **Свойства** - характеристики харакерные для всех машин. Количество колес, цвет, количество бензина... 
- **Методы** - команды, на которые может реагировать машина.	По сути функции, которые может вызывать каждый объект. 
- **Геттеры и сеттеры** - спец. методы, для добавления/получения свойств объекта (чтоб не использовать приватные свойста)

**Базовые принципы ООП**
- **Наследование** — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом. Нужно, прежде всего, для повторного использование кода. Cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
- **Абстракция** - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных.
- **Инкапсуляция** - ограничение доступа к данным и возможностям их изменения. Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.
- **Полиморфизм** — возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат. Cвойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

**Разыне модели (подходы) ООП**
- Компонентно-ориентированное программирование
- Прототипно-ориентированное программирование
- Агентно-ориентированное программирование

**Другие методологии программирования**
- **императивное** - вычисления описываются в виде инструкций, шаг за шагом изменяющих состояние программы.
- **декларативное** - описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между этими состояниями.
- **структурное** - декомпозиция. По-прежнему оперируем состоянием и инструкциями, однако вводится понятие составной инструкции (блока), инструкций ветвления и цикла.
- **процедурное** - исходная задача разбивается на меньшие (с помощью процедур) и это происходит до тех пор, пока решение всех конкретных процедур не окажется тривиальным.
- **модульное** - разделение функциональности на законченные блоки. Программа описанная в стиле модульного программирования — это набор модулей. Что внутри, классы, императивный код или чистые функции — не важно. Благодаря модулям впервые в программировании появилась серьезная инкапсуляция — возможно использовать какие-либо сущности внутри модуля, но не показывать их внешнему миру.
- **функциональное** - всё есть чистая функция, даже числа. Важно "отсутсвие состояния"
- **обощённое** - разделеие на шаблоны
- **реактивное** - ориентированное на потоки данных и распространение изменений. Должна существовать возможность легко выражать статические и динамические потоки данных, а также нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.
- всякие экзотические - автоматное, аппликативное, аспект/агент/компонент-ориентированное...<br> 
Немного подробнее: [«Забытые» парадигмы программирования](https://habr.com/ru/post/223253/)
...

**Принципы SOLID**
  <details>
    <summary>S: Single Responsibility Principle (<b>Принцип единственной ответственности</b>)</summary>
      Каждый класс должен решать лишь одну задачу.
  </details>
  
  <details>
    <summary>O: Open-Closed Principle (<b>Принцип открытости-закрытости</b>).</summary>
      Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.
  </details>
  
  <details>
    <summary>L: Liskov Substitution Principle (<b>Принцип подстановки Барбары Лисков</b>).</summary>
      Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
      Классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.
  </details>
  
  <details>
    <summary>I: Interface Segregation Principle (<b>Принцип разделения интерфейса</b>).</summary>
      Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. 
      Клиенты не должны зависеть от интерфейсов, которые они не используют.
  </details>
  
  <details>
    <summary>D: Dependency Inversion Principle (<b>Принцип инверсии зависимостей</b>).</summary>
        Объектом зависимости должна быть абстракция, а не что-то конкретное.
        Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
        Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
  </details>
  
**Другие принципы Объектно Ориентированнаого Дизайна** 
- **Закон Деметры** (англ. Law of Demeter, LoD) - каждый программный модуль:
    - должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.
    - должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
    - обращаться только к непосредственным «друзьям».
    **Ссылки**
    - [habr](https://habr.com/ru/post/319652/)
    - [wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
- **GRASP** (general responsibility assignment software patterns) — общие шаблоны распределения ответственностей 
  - Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения. Постоянно используешь в объекте какой-то внешний метод? Скорее всего, этот метод должен быть в этом объекте
  - высокое сцепление - код выполняющий одну задачу, должне быть в одном месте
  - низкая связность - модули не должны зависеть друг от друга (если они ссылаются друг на друга - это то же самое что у вас один большой модуль)
  - ... (всего 9 принципов)
  - [Wikipedia](https://ru.wikipedia.org/wiki/GRASP)
- **CQS** (Command Query Separation)
  - метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно. 
  - Другими словами, задавание вопроса не должно менять ответ. 
  - Более формально, возвращать значение можно только чистым, не имеющим побочных эффектов методам. Следует отметить, что строгое соблюдение этого принципа делает невозможным отслеживание количества вызовов запросов. 
  - Другими словами: если я спрашиваю у объекта "Ты админ?", он должен вернуть только tru или false. И не должен внутри заниматься изменением состояния
  - [Wikipediz](https://ru.wikipedia.org/wiki/CQRS)
- **Single level of Abstraction** (один уровень абстракции)
  - Каждый метод должен быть написан на одном уровне абстракции.
  - [Single level of abstraction (en)](https://medium.com/@yukas/single-level-of-abstraction-1e2bb6a645d7)

См видео "[Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)"
  
Ссылки:
- [code.mu - на пальцах](http://code.mu/books/javascript/oop/)
- [code.mu - тоже на пальцах](http://code.mu/books/php/oop/osnovy-raboty-s-objektno-orientirovannym-programmirovaniem-v-php-1.html)
- [habr - на пальцах 1](https://habr.com/ru/post/87205/)
- [habr - на пальцах 2](https://habr.com/ru/post/87119/)
- [Что такое ООП в паре слов](https://javarush.ru/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija)
- [habr - Понимание ООП в JS](https://habr.com/ru/company/enterra/blog/153365/)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Details_of_the_Object_Model)  
- [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)  
- [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)
  
<br></p></details>

#
<details><summary><b>UX/UI</b></summary><p>

  ---
  <details><summary>UX дизайнер -  планирует то, как вы будете взаимодействовать с интерфейсом и какие шаги вам нужно предпринять</summary>
      Когда изобретатель очередного точильного камня думал: будет ли он сидеть и сам нажимать педаль, или он упростит механизм, но приставит раба который будет раскручивать колесо рукой, то в тот момент он был UX дизайнером.
  </details>
  
  <details><summary>UI дизайнер - придумывает, как каждый из этих шагов будет выглядеть</summary>
      Человек, который думал, какой величины будет камень, какого цвета выбрать дерево для подставки и чем скрепить деревянные жерди (гвоздями или кожаными жгутами?) и какой длины будет ручка, был UI дизайнером.
  </details>
  
  <details><summary>Интерфейс - тот способ, каким бы в результате вы затачивали меч. Вместе со всеми решениями UX и UI.</summary>
  </details>
  
  См. отдельный файл-шпаргалку по UX-UI (скоро выложу)

<br></p></details>

#
<details><summary><b>Разное</b></summary><p>
  
  ---
  
  **Про что ещё спрашивали:**
  - лексическое всплытие
  - алгоритмическая сложность
  - теория нормализации данных
  - работа DOM браузера: "дорогие" опреации. Relayout / repaint
  - работа DOM браузера: "дорогие" опреации чтения (get.computer.style и т.д.)
  - предложить разные методы организации кэша для вычисления Фибоначчи (кэш ограничен 20 значениями, а поступить может хоть 10000 - как оптимизировать? часть кэша выделяем под хранение предыдущиз вычисленных значений. Рекурсия - самый дорогой вариант)
  - подготовить раздел про MVC
  - центральным для современных фреймворков является вопрос отслеживания изменений — то есть как фреймворк понимает, что что-то изменилось и необходимо применить новые изменения к DOM.
  - асинхронность и однопоточность JS- понимать, что это значит и чем обусловлено.
  - мало простого заучивания методов жизненного цикла компонента React — разберитесь, с какой целью они были добавлены.
  
  **Повторять**
 - Повторить JS eventloop
 - Вспоминать JS - замыкания и т.д.
 - Повторять основные понятия React.
 - Повторять устройство Redux (store, createStore, state, reducer, actions, action creators, dispatch, provider, connect, middleware,  mapDispatchToProps, mapStateToProps)

**Принципы программировани**
 - DRY
 - KISS
 - YAGNI
 +
 - SOLID (см ООП) 
 - GRASP
 - CQS
 - Law of Demeter  (см ООП)
 - Single level of Abstraction Principle
 +
 - Интересные идеи на тему: [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)

<br></p></details>

#
<details><summary><b>Ещё подборки вопросов-ответов</b></summary><p>

  ---

  - [Вопросы на собеседовании React.js](https://github.com/likezninjaz/react-ru-interview-questions)
    - JavaScript
      - Какие типы данных существуют в JavaScript?
      - Что такое цикл событий (event loop) и как он работает?
      - Что такое замыкание?
      - Что такое прототип объекта в JavaScript?
      - Как работает ключевое слово this?
      - Как работают методы apply(), call() и bind()?
      - Что такое Promise (Промис)?
    - React
      - Какие методы жизненного цикла компонента существуют в React?
      - Что такое Context в React и для чего он используется?
      - Что такое Виртуальная DOM?
      - Для чего нужен атрибут key при рендере списков?
      - В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?
      - Что такое PureComponent?
      - Что такое Компонент высшего порядка (Higher-Order Component, HOC)?
      - Что такое хуки в React?
      - Что такое порталы в React?
  - [Козлова О - React.js + Redux — interview questions](https://medium.com/@olgakozlova/react-js-redux-interview-questions-1-e6d2f12f2d79)
    - Зачем вообще нужен реакт?
    - Что такое виртуальный DOM?
    - Жизненный цикл React компонента?
    - Что такое JSX?
    - Stateless vs Stateful React компоненты?
    - Functional vs Class React компоненты?
    - Smart vs Dumb React компоненты?
    - Отличия props и state?
    - Архитектура Redux
  - [Козлова О - JS Interview Questions. Массивы](https://medium.com/@olgakozlova/javascript-interview-questions-part-i-arrays-e996f6433089)
    - Какие способы создать массив вы знаете?
    - Какие особенности существуют у массивов в JavaScript по сравнению с массивами в других языках программирования — C, C#?
    - Как можно узнать длину массива?
    - Можно ли перезаписать length массива?
    - Как можно перебрать все элементы массива?
    - Какие методы для работы с массивом как со стеком Вы знаете?
    - Что будет в переменной result после исполнения этого кода? (Array.prototype.push.apply(arr, [3, 4]))
    - Какие методы для работы с массивом как с очередью Вы знаете?
    - Какие методы изменения порядка элементов массива Вы знаете?
    - Что будет в переменной result после исполнения этого кода? (array.sort())
    - Каким условиям должна удовлетворять функция-comparator передаваемая методу Array.prototype.sort()?
    - Как преобразовать массив в строку?
    - Метод объединения массивов?
    - Метод создания подмассива из массива?
    - Метод заполнения элементов массива
    - Методы перебора элементов массива
    - Методы поиска элементов в массиве
    - Методы редукции массивов
    - Как проверить, является ли элемент массивом?
    - Какой typeof у массива?
    - Почему не рекомендуется работать с разнотипными и разреженными массивами?
    - Преобразование массивов в другие типы данных
  - [Козлова О - JS Interview Questions. Функции](https://medium.com/@olgakozlova/javascript-interview-questions-part-ii-functions-5bd513054382)
    - Какие способы создать функцию Вы знаете?
    - Какие способы вызвать функцию Вы знаете?
    - Какую функцию можно вызвать как конструктор?
    - Что происходит при вызове функции как конструктора?
    - Что будет в каждой переменной?
    - Что такое самоопределяемая функция? Приведите пример.
    - Как работает bind?
    - Что такое немедленно вызываемые функции? Примеры? Применение?
    - Что такое стрелочные фунцкии? Каковы их особенности?
    - Что такое вложенность функций?
    - Как можно работать с функцией как с объектом?
    - Как передаются аргументы в функцию? По ссылке или по значению?
    - Как получить все аргументы функции, если точное их количество не известно?
    - Каковы особенности работы с объектом arguments?
    - Что такое замыкания?
    - Как можно применять замыкания?
    - Какие проблемы могут вызвать замыкания?
  - [Вопросы и ответы на собеседовании по React.js](https://www.interviewhelper.org/ru/question/voprosy-i-otvety-na-sobesedovanii-po-react-js)
    - Как заставить компонент React перерендерится?
    - Назовите методы жизненного цикла компонента?
    - Какие методы компонента могут быть вызваны после некоторых изменений состояния?
    - Почему важно использовать key для отображения элементов списка ?
    - Как обрабатывать событие нажатия кнопки в React.js ?
    - Как передать параметр обработчику события или в callback?
    - Что произойдет, если передать функцию в метод setState ?
    - Что такое поднятие состояния вверх по иерархии в React (Lifting State Up)?
    - Как получить значение input?
    - Что такое строгий режим в React.js
    - Что такое порталы(Portals)?
    - В каком методе жизненного цикла нужно сделать HTTP-запрос ?
    - Что такое чистый компонент и когда он должен использоваться ?
    - Как сделать условный рендер в React.js? 
    - Как собрать React приложение в production режиме?
    - Где инициализировать состояние компонента?
    - Что представляют собой компоненты высшего порядка в React.js (HOC)?
    - Кода нужно использовать метод getDerivedStateFromProps(props, state)?
    - Что такое PropTypes и как их использовать?
    - Что такое stateless компоненты?
  - [Вопросы про React на собеседовании](https://www.kanby.ru/voprosyi-pro-react-na-sobesedovanii.html)
    - Что происходит, когда вы вызываете setState?
    - Какая разница между Элементом и Компонентом в React?
    - Когда вам использовать Class Component вместо Functional Component?
    - Что за refs в React и в чем их важность?
    - Что за keys в React и чем их важность?
    - Если вы создали в React элемент Twitter как в примере ниже, то как бы он выглядел?
    - В чем разница между controlled и uncontrolled компонентами?
    - В какой момент жизненного цикла вы применяется AJAX запросы и почему?
    - Что делает и почему важен shouldComponentUpdate?
    - Как вы скажете React строить в режиме Production и как это сделать?
    - Опишите, как в React обрабатываются события?
    - В чем разница между createElement и cloneElement?
    - Какой второй аргумент можно передать опционально в setState и какова его цель?
    - Что не так с этим кодом?
  - [Топ 15 вопросов о React.JS на собеседовании (другой перевод)](https://proglib.io/p/react-js-interview/)
    - Что делает setState?
    - В чем разница между элементом и компонентом React.JS?
    - В каких случаях Class Component лучше, чем Functional Component?
    - Что такое refs и с чем их едят?
    - React key – это…
    - Как бы выглядел приведенный ниже элемент Twitter в React?
    - Разница между компонентами controlled и uncontrolled
    - В каком моменте должны быть AJAX запросы и почему?
    - Что за зверь, этот shouldComponentUpdate?
    - Поговорим с React.JS: режим Production
    - Почему React.Children.map(props.children, () => ), а не props.children.map(() => )?
    - Опишите обработку событий в React.JS
    - В чем разница между cloneElement и createElement?
    - Какой второй аргумент может быть передан в setState?
  - [Вопросы на собеседование по React / Redux](https://webformyself.com/voprosy-na-sobesedovanie-po-react-redux/)
    - Что такое React?
    - Что такое Виртуальная DOM?
    - В чем разница между состоянием и свойством?
    - Какие существуют фазы жизненного цикла компонентов React?
    - Как работает React?
    - Что такое потомки?
    - Что такое состояние в React?
    - Что такое контролируемые компоненты?
    - Что такое Flux?
    - Что такое Redux?
    - Как изменяется состояние в Redux?
    - Что такое «хранилище» в Redux?
    - Что такое чистая функция?
    - Как бы вы отключили хранилище Redux, чтобы оно не принимало никаких изменений в состоянии?
  - [Козлова О - Вопросы из Яндекса](https://medium.com/@olgakozlova/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8%D0%B7-%D1%8F%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0-895261c94e16)
  - [Козлова О - Сети в вопросах и ответах. HTTP-протокол. AJAX. JSONP. CORS.COMET.](https://medium.com/@olgakozlova/%D1%81%D0%B5%D1%82%D0%B8-%D0%B2-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%B0%D1%85-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0%D1%85-http-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB-ajax-jsonp-cors-comet-53c60319a5a7)
  - [CSSSR - «И так сойдёт!» или главные ошибки кандидатов](http://blog.csssr.ru/2018/08/16/candidates-mistakes)

<br></p></details>

